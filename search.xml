<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Linux基础操作</title>
      <link href="2020/07/15/linux-ji-chu-cao-zuo/"/>
      <url>2020/07/15/linux-ji-chu-cao-zuo/</url>
      
        <content type="html"><![CDATA[<blockquote class="blockquote-center">linux 的常见，常用操作，备忘吧。</blockquote><a id="more"></a><p>目前还用不到生物云计算。</p><p>为什么生物学软件都是基于Linux操作系统？</p><ol><li>Linux 系统是开源免费的。</li><li>不需要图形界面，节约资源。</li><li>强大的命令行模式，适合自动化。</li><li>适合大规模的计算。</li></ol><h2 id="命令行和参数"><a href="#命令行和参数" class="headerlink" title="命令行和参数"></a>命令行和参数</h2><p>date 就可以看时间了<br>cal 显示日历<br>who 显示以登录的用户列表<br>id 用户id名称<br>uptime 显示系统运行的时间<br>last 显示最近用户登录的记录<br>clear 清空。<br>find 查找<br>file 查看文件属性<br>cut 切分文件<br>join 连接</p><h2 id="远程登录"><a href="#远程登录" class="headerlink" title="远程登录"></a>远程登录</h2><p>PuTTY 远程登录</p><p>一般我用vscode远程登录服务器。</p><h2 id="服务器文件传输"><a href="#服务器文件传输" class="headerlink" title="服务器文件传输"></a>服务器文件传输</h2><p>FileZilla 文件传输工具</p><p>ncbi ftp 网址可以登录ncbi服务器，佚名登录<br>Ftp Service </p><p>scp 传输命来可以实现传输。一般是用其他的传输工具。 </p><h2 id="13-display-图形查看工具"><a href="#13-display-图形查看工具" class="headerlink" title="13 display 图形查看工具"></a>13 display 图形查看工具</h2><p>一般可以vscode远程都可以实现这些功能，不用那么复杂。</p><h2 id="14-Linux-目录分析"><a href="#14-Linux-目录分析" class="headerlink" title="14 Linux 目录分析"></a>14 Linux 目录分析</h2><p>可以网上找找资料</p><h2 id="15-cd-与-ls"><a href="#15-cd-与-ls" class="headerlink" title="15 cd 与 ls"></a>15 cd 与 ls</h2><p>这种问题可以ranger 解决所以</p><p>cd - 后退命令<br>ls -lh<br>ls *.la 列出以la 结尾的文件</p><h2 id="16-baserc-环境配置"><a href="#16-baserc-环境配置" class="headerlink" title="16 baserc 环境配置"></a>16 baserc 环境配置</h2><p>etc 就是配置目录</p><p>.baserc 就是在开机时候执行的文件，</p><pre><code># 显示日期date # 显示一段话echo &quot;Hello Welcome to Linux&quot;# 设置命令别名alias work = &#39;cd ~/workspace&#39;</code></pre><p>grep “export” ~/.bashrc 表示在baserc中查找<code>export</code>这个单词。</p><h2 id="17-chmod-权限控制"><a href="#17-chmod-权限控制" class="headerlink" title="17 chmod 权限控制"></a>17 chmod 权限控制</h2><p>Linux 是一个多用户的系统，多任务的操作系统。</p><p>文件目录权限可分：</p><ul><li>可读：用r代表reads</li><li>可写：w代表write</li><li>可执行：x代表execute</li></ul><p>权限是十个字符<br><strong>drwxr-xr-x</strong> 1 theing theing  4096 Apr 18 22:57 ./<br>其中第一个字符为一个单位，后面三个字符为一个单位。<br>l 为连接文件<br>d 表示是一个文件夹</p><ul><li>表示为一个普通文件</li></ul><p>chmod 命令来控制文件权限</p><ul><li><p>0表示没有权限</p></li><li><p>1表示课执行权限</p></li><li><p>2表示可写权限</p></li><li><p>4表示可读权限</p></li><li><p>7：可读可写可执行 4+2+1</p></li><li><p>6：可读可写 4+2</p></li><li><p>5：可读可执行 4+1</p></li><li><p>700 属主主可读可写可执行，同用户组没有权限</p></li><li><p>755 属主可读可写可执行，同用户组只能可读可执行，组外用户只能可读可执行</p></li><li><p>644 属主可读可写，同组用户只能可读，组外用户只能可读</p></li></ul><pre><code>比如 这个文件就只能自己读写行chmod 700 -r *.test.py</code></pre><p>同一目录下的文件修改需要用到<code>R</code>递归，<code>*</code>通配符也可以用到。</p><h2 id="19-SuperUser"><a href="#19-SuperUser" class="headerlink" title="19 SuperUser"></a>19 SuperUser</h2><p>fdisk 就是format disk格式化磁盘</p><p>useradd gene 可以创建一个gene的用户</p><p>passwd gene 可以给这个用户添加密码</p><p>groupadd bioinfo 这样就可以创建一个bioifo的组</p><p>usermod -G bioinfo gene 就可以将gene 添加到bioinfo 的组中</p><p>groups gene 可以查看用户所在的组</p><p>userdel gene 可以删除用户</p><h2 id="20-获取帮助"><a href="#20-获取帮助" class="headerlink" title="20 获取帮助"></a>20 获取帮助</h2><p>程序是 按照一定的预设规则来处理一定的事情。</p><p>软件指程序与其相关文档或其他从属物的集合。</p><p>软件 = 程序 + 文档</p><p>info ls<br>info cd 等也可以查看命令信息</p><p>man </p><h2 id="21-Linux-文件"><a href="#21-Linux-文件" class="headerlink" title="21 Linux 文件"></a>21 Linux 文件</h2><p>系统一切基于文件</p><p>修改文件后缀名，</p><blockquote><p>mv K12fna k12</p></blockquote><table><thead><tr><th>后缀</th><th>解释</th></tr></thead><tbody><tr><td>.asn</td><td>genome record in asn.1 format</td></tr><tr><td>.faa</td><td>protein sequences in fasta format, text file .ffn</td></tr><tr><td>.frn</td><td>rna coding portions of the genome segments .gbk</td></tr><tr><td>.gff</td><td>genome features</td></tr><tr><td>.ppt</td><td>protein table</td></tr><tr><td>.rnt</td><td>rna table</td></tr><tr><td>.rpt</td><td>summary report</td></tr></tbody></table><blockquote><p>ls -ld /dev/ 可以查看文件属性<br>ls -lh /dev/ </p></blockquote><blockquote><p>stat K12.fna 也可以查看文件属性</p></blockquote><p>du 可以查看文件的大小个目录的大小  </p><h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><p>主要讲了移动，重命名，复制粘贴等操作。</p><p>软连接，<code>ln -s</code>基本可以代替<code>cp</code>命令，因为连接可以节省资源，还有一种硬链接（<code>ln</code>)，允许一个文件有多个路径，基本也是软连接，但是你删除本体的时候就会转移，永远无法真正的删除，只能将所有的文件连接删除。</p><p>谨慎使用rm命令 </p><h2 id="22-目录操作"><a href="#22-目录操作" class="headerlink" title="22 目录操作"></a>22 目录操作</h2><p>ranger 也可以</p><p>目录和文件夹一个意思<br>mkdir 创建目录</p><p>可能就是一个通配符的使用上，我不是很流畅</p><h2 id="23-文件查看"><a href="#23-文件查看" class="headerlink" title="23 文件查看"></a>23 文件查看</h2><p><code>less</code>命令可以查看文件少量的文字信息，推荐使用<br><code>more</code>可以查看文件的大量信息</p><p>less 可以读取很大的文本，因为他只是将一部分内容加载到内存中，而在windows中就必须将整个文本读取到内存中。</p><p>less 中可以用”/“来查询需要的字符，”/?”就是向上搜索。</p><p>其次还可以用<code>cat</code>命令来查看一个小的文本文件，小的命令脚本。</p><p><code>tac</code> 与<code>cat</code>相反 是把文本反过来显示</p><p>head命令可以显示前面的10行，可以更改</p><blockquote><p>head -20<br>head -n 20<br>显示前面的20行的文字</p></blockquote><h2 id="24换行符"><a href="#24换行符" class="headerlink" title="24换行符"></a>24换行符</h2><blockquote><p>head -10 linux.fasta |cat -A<br>可以显示10行中显示换行和回车的符号</p></blockquote><p>linux 中的转换工具</p><p>dos2unix : windows 转换linux<br>unix2dos : linux 转换windows<br>unix2mac : linux 转换mac<br>mac2unix : mac 转换为linux</p><h2 id="25-vim文本编辑器"><a href="#25-vim文本编辑器" class="headerlink" title="25 vim文本编辑器"></a>25 vim文本编辑器</h2><p>vim有三种模式<br>命令模式，插入模式，可视化模式</p><p>在vimrc中</p><pre><code># 表示语法高亮syntax on # 显示行号set nu # 文本为utf-8的格式支持中文set encoding=utf-8# 打开光标的行列显示功能set ruler # 不设置备份set nobackup# 一个tab等于4个空格set tabstop=4</code></pre><h2 id="26-vim-高级技巧"><a href="#26-vim-高级技巧" class="headerlink" title="26 vim 高级技巧"></a>26 vim 高级技巧</h2><p>不过这些都可以用vscode替代。习惯用vscode扩展。</p><p>ctrl + B 往前移一页<br>ctrl + F 往前移一页<br>ctrl + U 屏幕往后移动半页<br>w 每次移动一个单词<br>6x 表示删除光标后面的6个字符<br>d6 删除6行<br>yy 表示复制<br>pp 表示粘贴</p><p>ctrl + r 后退<br>. 可以重复上一次操作<br>? 可以搜索要查找的内容，用N查看下一处</p><p>在编辑模式下用ctrl+P 或ctrl + N 来自动补齐<br>命令模式下nohl（no heaght line 高亮的意思）可以去除高亮。</p><blockquote><p>:%s/human/humwoman/gc 表示全部替换human&gt;humwoman</p></blockquote><p>也可展示的将vim后台，命令模式下</p><blockquote><p>:sh 可进入base ctrl + D 可回到vim中</p></blockquote><blockquote><p>:split 可用于分屏显示 ctrl + w可用于各个屏幕之间的切换<br>:vsplit 可用于纵向分屏<br>:onoly 只显示一个窗口</p></blockquote><h2 id="27-文件的压缩"><a href="#27-文件的压缩" class="headerlink" title="27 - 文件的压缩"></a>27 - 文件的压缩</h2><p>zip gzip bzip2;</p><h4 id="gzip"><a href="#gzip" class="headerlink" title="gzip"></a>gzip</h4><p><code>gzip seq.fna</code>gzip 后面加上要压缩的文件就可以用于压缩，压缩后可用less、zcat查看<br><code>gzip -b</code>或者<code>gunzip</code>后面接文件就可以解压了</p><p>具体可help 查看使用信息</p><h4 id="zip-适用于打包"><a href="#zip-适用于打包" class="headerlink" title="zip 适用于打包"></a>zip 适用于打包</h4><p>zip + 打包后的文件名称.zip结尾 + 要打包的文件<br>具体可 –help 查看使用手册<br>unzip 可用于解压</p><h4 id="bzip2-压缩效率最高"><a href="#bzip2-压缩效率最高" class="headerlink" title="bzip2 压缩效率最高"></a>bzip2 压缩效率最高</h4><p>bzip2 + 要压缩的文件<br>bunzip2 + 要解压的文件<br>具体可help查看使用帮助</p><h4 id="RAR压缩文件"><a href="#RAR压缩文件" class="headerlink" title="RAR压缩文件"></a>RAR压缩文件</h4><p>用rarlinux 工具</p><p>不可以用了一个压缩工具后用其他的压缩用具继续压缩</p><h2 id="28-文件的打包tar"><a href="#28-文件的打包tar" class="headerlink" title="28 文件的打包tar"></a>28 文件的打包tar</h2><p>tar 工具是很强大的工具，可以help查看</p><p>一般用 <code>tar -zxvf</code> 去解压文件</p><p>如果遇到要把文件添加到压缩文件中怎么办，不用解压后添加在压缩，<br>可以用-r 选项添加文件，-u可以替换文件。</p><h2 id="29-生物软件的安装"><a href="#29-生物软件的安装" class="headerlink" title="29 生物软件的安装"></a>29 生物软件的安装</h2><p><a href="www.mybiosoftware.com">一个生物信息软件的网站</a>，这是一个生物信息的导航网站，</p><h2 id="30-文件统计及其切分"><a href="#30-文件统计及其切分" class="headerlink" title="30 文件统计及其切分"></a>30 文件统计及其切分</h2><h4 id="文件的统计"><a href="#文件的统计" class="headerlink" title="文件的统计"></a>文件的统计</h4><p>wc + 文件名   统计<br>结果分别行数，字数，字节数，文件名</p><h4 id="文件的拆分-都不是很常用"><a href="#文件的拆分-都不是很常用" class="headerlink" title="文件的拆分(都不是很常用)"></a>文件的拆分(都不是很常用)</h4><p>split 和 cut 命令</p><p>split 是按照行切分数据而cut是按照列切分数据的</p><p>cut -b 1 blast_m8.list 就是将文件中每一行第一个字母输出出来。</p><p>cut -b 1-28 blast_m8.list 就是将文件中每一行1-28的字母输出出来</p><p>其中cut 可用到域这个东西， “|”，竖线中的文字代表着一个域。<br><code>cut -d &quot;|&quot;-f 4 blast_m8.list</code> 提取第四个域中的内容。</p><h2 id="31-文件的比较域校验"><a href="#31-文件的比较域校验" class="headerlink" title="31 文件的比较域校验"></a>31 文件的比较域校验</h2><p>diff和cmp来比较两个文件之间的差异</p><p>diff主要是以行为单位比较。<br>cmp主要是以字节为单位比较。</p><blockquote><p>diff gene_v1.fa gene_v2.fa<br>这样就可以比较出两个文件之间的差异。<br><img src="https://s1.ax1x.com/2020/05/17/YgLxBD.png" alt="YgLxBD.png"></p></blockquote><p>1c1表示第一个文件的第一行有变化，其他a表示增加，d表示删除</p><h2 id="32-快捷方式"><a href="#32-快捷方式" class="headerlink" title="32 快捷方式"></a>32 快捷方式</h2><p>就是要使用全路径才可以在任意目录下使用命令。</p><p>系统的命令主要是放在bin和sbin下也就是/usr/bin/</p><h3 id="方式"><a href="#方式" class="headerlink" title="方式"></a>方式</h3><p>将程序的执行程序添加到path变量中，或者将软件的执行程序拷贝到/usr/bin或者/usr/loca/bin中</p><p>其中一个好的方法就是在程序的文件下创建一个bin目录存放所有要执行的程序软连接ln -s，然后将这个目录添加到PATH路径如</p><blockquote><p>export PATH=”$PATH:/ifsl/Software/bin/:$PATH/“</p></blockquote><h2 id="33-常见问题"><a href="#33-常见问题" class="headerlink" title="33 常见问题"></a>33 常见问题</h2><p>不断的实践操作， </p><h2 id="34-Linux-进程管理"><a href="#34-Linux-进程管理" class="headerlink" title="34 Linux 进程管理"></a>34 Linux 进程管理</h2><p>uptime 是系统运行的时间，<br>w 直接现实所有用户的信息</p><p>Linux 下每个进程的优先级是不一样的，一共40个级别</p><p>ps 和 top 可以查看进程</p><p>修改进程可以用nice 命令</p><h4 id="进程的前后台处理"><a href="#进程的前后台处理" class="headerlink" title="进程的前后台处理"></a>进程的前后台处理</h4><p>可以在要运行的程序后面加一个 “&amp;”，这样就可以后台运行了<br>jobs 可显示后台运行的程序<br>使用fg可以把后台程序调回前台，调回前台时无法使用命令，可以使用ctrl+z将程序暂停，jobs可以显示程序的暂停情况，bg就可以后台继续运行程序</p><p>其次还要nohup 可以在用户退出时继续执行程序，继而还要weit，sleep </p><h2 id="35-进程管理top"><a href="#35-进程管理top" class="headerlink" title="35 进程管理top"></a>35 进程管理top</h2><p>这个命令就相当于win中的资源管理器，win是模仿Linux加上了图形界面 </p><p>东西有点多，，可以网上查找资料。</p><p>在top模式下，按K可以进入kill也就是杀死进程，输入进程的PID就可以杀死进程。</p><p>进程终止信号，</p><ul><li>1 终端断线</li><li>2 中断，相当于Ctrl + C</li><li>3 退出（同Ctrl+\）</li><li>15 终止进程，默认为15</li><li>9 强制终止</li><li>18 继续（与STOP相反，fg/bg命令）</li><li>19 暂停（同Ctrl+Z)</li></ul><p>在top中查看到PID后可以直接在终端中使用kill命令，</p><blockquote><p>kill -9 30530 </p></blockquote><p>强制终止30530进程</p><h2 id="36-进程管理ps命令"><a href="#36-进程管理ps命令" class="headerlink" title="36 进程管理ps命令"></a>36 进程管理ps命令</h2><p>top是动态的，ps是静态的<br>ps 可显示当前的进程，不包括系统进程</p><h4 id="ps-常用命令"><a href="#ps-常用命令" class="headerlink" title="ps 常用命令"></a>ps 常用命令</h4><blockquote><p>ps -A 列出所有进程<br>ps -a 列出终端上的进程，包括其他用户的进程<br>ps -r 显示运行中的进程     </p></blockquote><p>常用的选项组和是</p><blockquote><p>ps -aux | less<br>ps -lux | less<br>ps -fx 可以用竖型格式显示进程</p></blockquote><p>东西太多，可以参考网上的教程，也可以help 查看文档。</p><blockquote><p>pstree 可以查看进程之间的关系<br>pstree -a 可以查看进程的完整属性，包括路径</p></blockquote><h2 id="37-数据流的重定向"><a href="#37-数据流的重定向" class="headerlink" title="37 数据流的重定向"></a>37 数据流的重定向</h2><p>echo 在终端中输出一串信息</p><p>bc 计算器<br>scale = 4 表示存在四个小数，可以计算四个浮点数<br>quit 可以退出计算器</p><h4 id="“-gt-”表示数据重定向，经常用到，”-gt-gt-”表示追加到文件的末尾"><a href="#“-gt-”表示数据重定向，经常用到，”-gt-gt-”表示追加到文件的末尾" class="headerlink" title="“&gt;”表示数据重定向，经常用到，”&gt;&gt;”表示追加到文件的末尾"></a>“&gt;”表示数据重定向，经常用到，”&gt;&gt;”表示追加到文件的末尾</h4><p>可用于文件的合并</p><blockquote><p>cat –help &gt;cat_help.txt<br>可以把显示在屏幕上的帮助信息写入到help.txt文件中。</p></blockquote><blockquote><p>cat seq1.fna seq2.fna &gt;seqs.fna</p></blockquote><p>这样就可以把两个文本合并在一起，但是可以用vscode远程这些东西。</p><h4 id="问题，"><a href="#问题，" class="headerlink" title="问题，"></a>问题，</h4><p>当一个管道被占用，输出不了信息。可以大于前面添加一个2也就是另一个管道。</p><blockquote><p>cat -2 2&gt;&gt;error.txt</p></blockquote><h2 id="38-命令协作管道"><a href="#38-命令协作管道" class="headerlink" title="38 命令协作管道"></a>38 命令协作管道</h2><p>基本理解可以用蓄水池的出口用另一个管子另外接一个管子使改变流出方向，进行另外的处理。</p><p>例子：</p><blockquote><p>echo “123456789”|wc<br>结果使10个其中包含了换行符，其实是9个字符</p></blockquote><blockquote><p>echo -n “123456789”|wc -m<br>-n 表示 去除结尾的换行符，-m 表示只统计字符</p></blockquote><p>例： </p><blockquote><p>ls -a *.fna | wc -l<br>就可以统计目录下以.fna 结尾的文件</p></blockquote><p>其中的管道在实际运用中可以大量使用到，要即使查看资料</p><h2 id="39-文本排序sort"><a href="#39-文本排序sort" class="headerlink" title="39 文本排序sort"></a>39 文本排序sort</h2><p>排序情况：</p><ol><li>根据数字大小进行排序;</li><li>根据字符大小排序；</li><li>根据文件指定的顺序进行排序。</li></ol><p>sort 默认是从首字母从大到小排序。</p><blockquote><p>sort -n<br>根据数字大小排序<br>-r 相反的顺序排序，具体可以–help</p></blockquote><h2 id="40-文件搜索"><a href="#40-文件搜索" class="headerlink" title="40 文件搜索"></a>40 文件搜索</h2><p>which 查找命令<br>locate 可以查找所有相关的文件，基本就是模糊查找</p><p>find 一般不要在根目录下操作</p><h2 id="41-文本筛选grep"><a href="#41-文本筛选grep" class="headerlink" title="41 文本筛选grep"></a>41 文本筛选grep</h2><ol><li>find 搜索目录下满足条件的文件；</li><li>grep 搜索文件内满足条件的内容行；全称是 全局正则表达式版本。</li></ol><h3 id="grep-的使用"><a href="#grep-的使用" class="headerlink" title="grep 的使用"></a>grep 的使用</h3><p>有时要看–help 参考一些别人写的常用功能。<br>如：</p><pre><code>grep &quot;&gt;&quot; gene.ffn |wc</code></pre><p>表示在gene.ffn这个文件中搜索”&gt;” 输入管道”|”用wc统计，一般可用于fasta这种基因序列，一条序列都是”&gt;”符号开头的。 </p><blockquote><p>ls </p></blockquote><h2 id="42-正则表达式"><a href="#42-正则表达式" class="headerlink" title="42 正则表达式"></a>42 正则表达式</h2><p>要想真正发挥grep的功能必须要掌握正则表达式的功能，正则表达式也适用于其他语言</p><blockquote><p>grep “eat” 001.txt </p></blockquote><p>就会把文本中所以含有eat 的行显示出来。这个时候就会用到正则表达式。</p><blockquote><p>grep “^eat” 001.txt 就只能搜索到以eat开头的词。</p></blockquote><blockquote><p>grep “eat&amp;” 001.txt 就只能搜索到以eat结尾的词。</p></blockquote><blockquote><p>grep “\beat\b” 001.txt \b为单词锚定符，这样就只能匹配到eat的词组。</p></blockquote><h3 id="正则中的符号表示"><a href="#正则中的符号表示" class="headerlink" title="正则中的符号表示"></a>正则中的符号表示</h3><ul><li><p>. 任何单个字符的通配符。</p></li><li><p>\ 表示转义符，比如：. 表示“.”</p></li><li><ul><li>通配符，是多个字符的通配符</li></ul></li><li><p><code>grep  &quot;go.*gle&quot; 001.txt</code> 能匹配所有以go开头以gle结尾的词组。</p></li><li><p>？ 表示{0，1}，0或者1次</p></li><li><ul><li>表示{1，}，一次以上</li></ul></li><li><ul><li>表示{0，}，0到无穷大</li></ul></li><li><p><code>grep -E &quot;go&#123;1,8&#125;gle&quot; 001.txt</code> 表示能匹配1-8个字符 </p></li><li><p><code>grep &quot;\(google\)&quot; 001.txt</code> 表示已google为一个字符进行匹配。</p></li><li><p>| 表示或，比如<code>grep -E &quot;beat|seat|heat|feat&quot; 001.txt</code>表示如果符合其中一个就可以匹配</p></li><li><p>[] 表示一个字符集列表，如<code>grep [bfhs]eat 001.txt</code>就可以从[]中符合的字符中进行匹配。只匹配单个字符。[a-z]匹配所有小字母；[A-Z]匹配所有大写的字母；[0-9]表示匹配所有数字。</p></li><li><p>\w单词，[A-Za-z0-9]，单词包括字母，数字和下划线。</p></li><li><p>\s空白，是字符集换页、制表、换行、回车以及空格[\f\t\n\r] 的简写；</p></li><li><p>\d 匹配所有数字[0-9].</p></li><li><p>\W 表示非字符</p></li><li><p>\D 表示非数字</p></li><li><p>\S 非空白字符</p></li></ul><h2 id="sed–波流（一）"><a href="#sed–波流（一）" class="headerlink" title="sed–波流（一）"></a>sed–波流（一）</h2><p>强大是文本编辑工具，sed &amp; awk </p><ul><li>sed 全称是Stream EDitor ，是一种流编辑器。相当于一个磨具，能对数据进行增删改查等操作，形成固定的格式。</li><li>sed 一次处理一行，处理存于一个模式缓存空间</li><li><code>sed -e &#39;s/GI/gi/g&#39; seq.fna</code>， 其中-e一般可以不写，s表示一种模式，为替换模式，寻找GI替换为gi，g表示globe全局搜索替换，默认是只替换一次，所以都加上g。也可以写数字，表示替换几次</li></ul><!--<img src="https://s1.ax1x.com/2020/05/21/Yquw5j.png" alt="Yquw5j.png" border="0" />--><p><img src="https://s1.ax1x.com/2020/05/21/Yquw5j.png" alt="Yquw5j.png"></p><ul><li><code>sed -e &#39;/^\s*$/d&#39; seq_with_space.fna</code>，正则中表示一个空白行，d表示删除。这样就可以删除所有空白的行。</li><li>`sed -n ‘1307p’ seq.fna 表示输出1307行的内容。</li></ul>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>生物信息学知识</title>
      <link href="2020/06/29/sheng-wu-xin-xi-xue-zhi-shi/"/>
      <url>2020/06/29/sheng-wu-xin-xi-xue-zhi-shi/</url>
      
        <content type="html"><![CDATA[<blockquote class="blockquote-center">喜欢一件事就去做吧，看看究竟是什么，未完待更。</blockquote><a id="more"></a><h2 id="第二章：生物数据库"><a href="#第二章：生物数据库" class="headerlink" title="第二章：生物数据库"></a>第二章：生物数据库</h2><h3 id="数据库分类"><a href="#数据库分类" class="headerlink" title="数据库分类"></a>数据库分类</h3><ul><li>核酸数据库<ul><li>一级核酸数据库，</li></ul></li><li>蛋白质数据库<ul><li>一级蛋白质数据库，一级蛋白质结构数据库</li></ul></li><li>专用数据库<ul><li>二级核酸数据库，二级蛋白质数据库</li></ul></li></ul><h3 id="文献数据库-PubMed"><a href="#文献数据库-PubMed" class="headerlink" title="文献数据库 PubMed"></a>文献数据库 PubMed</h3><p>搜索中：</p><ul><li>Down [AU] 表示搜索的 Down这个人（作者）</li><li>Down [TI] 表示按标题搜索这个词</li><li>Down [AD] 按实验室地址搜索这个词</li><li>Down      在任意地方搜索这个词</li></ul><h3 id="一级核酸数据库-GenBank"><a href="#一级核酸数据库-GenBank" class="headerlink" title="一级核酸数据库 GenBank"></a>一级核酸数据库 GenBank</h3><ul><li>NCBI 美国</li><li>ENA 欧洲</li><li>DDBJ 日本</li><li>INSDC　国际核酸序列数据库（由以上三大数据库构成，使得以上的数据库数据都大概相同）</li></ul><h3 id="2-4-4-基因组数据库"><a href="#2-4-4-基因组数据库" class="headerlink" title="2.4.4 基因组数据库"></a>2.4.4 基因组数据库</h3><ul><li>ensembl 脊椎动物数据库</li><li>jcvi 微生物数据库</li></ul><h3 id="2-6-二级核酸数据库（比较多）"><a href="#2-6-二级核酸数据库（比较多）" class="headerlink" title="2.6 二级核酸数据库（比较多）"></a>2.6 二级核酸数据库（比较多）</h3><ul><li>RefSep 数据库：参考序列数据库，人工精选出的非冗余数据库。</li><li>dbEST 数据库：表达序列标签数据库，不同物种的表达序列标签。</li><li>Gene 数据库：提供基因序列注释和检索服务。</li><li>ncRNAdb ：非编码RNA数据库，存放已发表的microRNA序列和注释。</li></ul><h3 id="2-7-一级蛋白质数据库"><a href="#2-7-一级蛋白质数据库" class="headerlink" title="2.7 一级蛋白质数据库"></a>2.7 一级蛋白质数据库</h3><ul><li>一级蛋白质-序列-数据库<ul><li>swissprot 人工注释的蛋白质数据库，冗余的小，可信度高。</li><li>RrEMBL 计算机注释的数据库，数据量大，可信度低，冗余量大。</li><li>PIR 蛋白质信息资源数据库，是一个支持基因组学，蛋白质组学和系统生物学研究的综合公共生物信息学资源。</li><li>UniProt 三层数据库<ul><li>UniParc：收录所有子库中的蛋白质序列，量大，粗糙。</li><li>UniRef：归纳了UniProt几个主要数据库并将重复序列去除后的数据库。</li><li>UniProtKB：有详细注释并连接了其他数据库，分为：UniProtKB/Swiss-Prot和UniProtKB/TrEMBL。我们主要用Swiss-prot </li></ul></li></ul></li><li>一级蛋白质-结构-数据库</li></ul><h3 id="2-8-一级蛋白质数据库PDB-生物大分子3D结构的数据库"><a href="#2-8-一级蛋白质数据库PDB-生物大分子3D结构的数据库" class="headerlink" title="2.8 一级蛋白质数据库PDB-生物大分子3D结构的数据库"></a>2.8 一级蛋白质数据库PDB-生物大分子3D结构的数据库</h3><ul><li>这些生物大分子除了蛋白质以外还包括核酸及两者的复合物。</li></ul><h3 id="2-9-二级蛋白质数据库-Pfam-CATH-SCOP2"><a href="#2-9-二级蛋白质数据库-Pfam-CATH-SCOP2" class="headerlink" title="2.9 二级蛋白质数据库 Pfam, CATH, SCOP2"></a>2.9 二级蛋白质数据库 Pfam, CATH, SCOP2</h3><ul><li>Pfam 蛋白质结构域家族的集合</li><li>CATH <ul><li>class </li><li>architecture</li><li>topology</li><li>homologous superfamily</li></ul></li><li>SCOP2  <ul><li>class 主要的二级结构成分</li><li>fold 空间的几何关系</li><li>super family 远源的蛋白质进化关系</li><li>family 相近的蛋白质进化关系</li></ul></li></ul><h3 id="2-10-专用数据库-KEGG-OMIM"><a href="#2-10-专用数据库-KEGG-OMIM" class="headerlink" title="2.10 专用数据库 KEGG OMIM"></a>2.10 专用数据库 KEGG OMIM</h3><ul><li>KEGG 京都基因组百科全书，是关于基因、蛋白质、生化反应及通路的综合生物信息数据库，由多个子库构成。</li><li>OMIM 人类遗传疾病及相关位点的详细信息 </li></ul><h2 id="第三章：序列比较"><a href="#第三章：序列比较" class="headerlink" title="第三章：序列比较"></a>第三章：序列比较</h2><h3 id="3-1序列"><a href="#3-1序列" class="headerlink" title="3.1序列"></a>3.1序列</h3><ul><li>蛋白质序列：由20个不同字母（氨基酸）排列组成。</li><li>核酸序列：由4个不同的字母（碱基）排列组成。</li><li>fasta格式：第一行大于号加名称或其他注释，第二行以后每行60个字母（也有80个的，不一定）</li></ul><p><strong>比较的目的就是确定相似性</strong></p><h3 id="3-3-替换计分矩阵"><a href="#3-3-替换计分矩阵" class="headerlink" title="3.3 替换计分矩阵"></a>3.3 替换计分矩阵</h3><ul><li>反映残基之间相互替换率的矩阵，它描述了残基两两相似的量化关系。分为：<ul><li>DNA替换计分矩阵</li><li>蛋白质替换计分矩阵。</li></ul></li></ul><h4 id="3种常见的DNA序列的替换计分矩阵"><a href="#3种常见的DNA序列的替换计分矩阵" class="headerlink" title="3种常见的DNA序列的替换计分矩阵"></a>3种常见的DNA序列的替换计分矩阵</h4><ul><li>等价矩阵</li><li>转换-颠倒矩阵<ul><li>嘌呤有两个环，嘧啶只有一个环</li><li>转换环数不变A - G、C - T</li><li>颠倒环数发生变化，A - C、T - G </li><li>转换发生的频率要比颠倒高。</li><li>转换得分为-1 ，而颠倒得分为-5.</li></ul></li><li>BLAST 矩阵（就是好）<ul><li>令被比对的两个核苷酸相同时得分为+5，反之为-4，</li><li>这个矩阵广泛地被DNA序列比较采用。</li></ul></li></ul><h4 id="3种常见的蛋白质序列的替换计分矩阵"><a href="#3种常见的蛋白质序列的替换计分矩阵" class="headerlink" title="3种常见的蛋白质序列的替换计分矩阵"></a>3种常见的蛋白质序列的替换计分矩阵</h4><ul><li><p>等价矩阵（较少使用）</p><ul><li>相同氨基酸匹配得分1，不同氨基酸间替换得分0。</li></ul></li><li><p>PAM 矩阵（最广泛使用）- 序列的差异度</p><ul><li>基于进化原理。如果两种氨基酸替换频繁，说明自然界易接受这种替换，那个这对氨基酸得分就高。</li></ul></li><li><p>BLOSUM 矩阵 - 相似度</p></li><li><p><strong><em>关系较远的时候BLOSUM-45更具优势，关系较近的序列用PAM或BLOSUM-62作出的比较差异不大。常用BLOSUM-62矩阵。</em></strong></p></li></ul><h3 id="3-4-序列两两比较-打点法"><a href="#3-4-序列两两比较-打点法" class="headerlink" title="3.4 序列两两比较-打点法"></a>3.4 序列两两比较-打点法</h3><ul><li><h3 id="3-5-序列两两比较-序列比对法"><a href="#3-5-序列两两比较-序列比对法" class="headerlink" title="3.5 序列两两比较-序列比对法"></a>3.5 序列两两比较-序列比对法</h3></li><li><p>needleman-Wunsch 算法，</p></li><li><img src="https://s1.ax1x.com/2020/04/14/JSm1dU.png" alt="JSm1dU.png" border="0" /><!--- ![JSm1dU.png](https://s1.ax1x.com/2020/04/14/JSm1dU.png)--></li><li><p>全局比对（用于比对两个长度近似的序列）</p></li><li><p>局部比对（用于比对一长一短的两条序列）</p></li></ul><h3 id="3-6-一致度和相似度"><a href="#3-6-一致度和相似度" class="headerlink" title="3.6 一致度和相似度"></a>3.6 一致度和相似度</h3><ul><li>一致度 = （一致字符串的个数/全局比对的长度）*100%</li><li>相似度 = （一致及相似的字符的个数/全局比对的长度）*100%</li></ul><h3 id="3-7-在线双序列比对工具"><a href="#3-7-在线双序列比对工具" class="headerlink" title="3.7 在线双序列比对工具"></a>3.7 在线双序列比对工具</h3><ul><li>EMBL 全局双序列比对工具</li><li>gap 开头和gap 结尾的意义，<ul><li>设置的gap开头大，比较集中，序列不容易打开，</li><li>gap 开头小，gap 结尾大，序列容易打开，</li></ul></li><li>EMBL 局部双序列对比工具</li></ul><p><strong>比对工具</strong><br><img src="https://s1.ax1x.com/2020/04/14/JStBjO.png" alt="JStBjO.png" border="0" /></p><!--![JStBjO.png](https://s1.ax1x.com/2020/04/14/JStBjO.png)--><h3 id="3-8-BLAST-搜索"><a href="#3-8-BLAST-搜索" class="headerlink" title="3.8 BLAST 搜索"></a>3.8 BLAST 搜索</h3><ul><li>可以用作寻找相同或相似的序列，一般NCBI、PDB、Uniprot都提供BLAST搜索服务。</li><li>blastp 用蛋白质搜索蛋白质序列的数据库。</li><li>blastn 用核酸序列搜索核酸序列数据库</li><li>blastx 将核酸序列按6条链翻译成蛋白质序列后搜索蛋白质序列数据库</li><li>tblastn 用蛋白质序列搜索核酸序列数据库，数据库中的核酸序列要按6条链翻译成蛋白质序列后再搜索。</li><li>tblastx 将核酸序列按6条链翻译成的蛋白质序列后再搜索核酸序列数据库，数据库中的核酸序列要按6条链翻译成的蛋白质序列后再搜索。</li></ul><img src="https://s1.ax1x.com/2020/04/14/JSfsr4.png" alt="JSfsr4.png" border="0" /><!--![JSfsr4.png](https://s1.ax1x.com/2020/04/14/JSfsr4.png)--><p>只运用blast只能搜索到十分相近的序列，而其他哪些远亲就找不到了，就是朋友的朋友找不到了。</p><ul><li><p>PSI-BLAST（特异性迭代BLAST） 可将搜索出来的序列再用来搜索。</p></li><li><p>PHI-BLAST（模式识别BLAST）能找到与输入序列相似的符合某种特定模式的序列。</p><ul><li>如：以Asn开始，然后紧跟除了Pro之外的任何一个氨基酸，再紧跟Ser或Thr，再紧跟除了Pro外的任何一个氨基酸。写法要用到正则表达N{P}[ST]{P}</li></ul></li><li><p>“{}”表示除什么以外，”[]”表示其中之一，”x”表示任意字符，”(3,7)”表示3到7个前面的字符。</p></li><li><p>一般我们可以用smartBLAST</p></li><li><p>网上的免费的搜索工具</p></li></ul><img src="https://s1.ax1x.com/2020/04/14/Jp9bPx.png" alt="Jp9bPx.png" border="0" /><!--![Jp9bPx.png](https://s1.ax1x.com/2020/04/14/Jp9bPx.png)--><h3 id="3-9-多序列比对介绍"><a href="#3-9-多序列比对介绍" class="headerlink" title="3.9 多序列比对介绍"></a>3.9 多序列比对介绍</h3><p>两条以上的生物序列进行全局比对。 </p><p>用途：</p><ol><li>确认：一个未知的序列是否属于某个家族</li><li>建立：系统发生树，查看物种间或序列间的关系。</li><li>模式识别</li><li>已知推未知</li><li>预测蛋白质/RNA二级结构等，，</li></ol><p>使用多序列的几点要求：</p><ol><li>太多不行。不能超过50条，一般10-15条</li><li>关系太远不行。</li><li>关系太近不行。</li><li>短序列不行。应该都是差不多的序列。</li><li>有重复序列的不行。</li></ol><p>多序列对比工具<br><img src="https://s1.ax1x.com/2020/04/14/JpiY5R.png" alt="JpiY5R.png" border="0" /></p><!--![JpiY5R.png](https://s1.ax1x.com/2020/04/14/JpiY5R.png)--><h3 id="3-10-在线序列比对"><a href="#3-10-在线序列比对" class="headerlink" title="3.10 在线序列比对"></a>3.10 在线序列比对</h3><p>序列文件格式：</p><ul><li>score_html file 很好看的网页格式</li><li>clustalw_aln file 多序列比对用的格式</li><li>fasta_aln file 一条序列一条序列</li><li>phylip file 方便建树用的格式<br>格式转换工具：fmtseq sequence conversion</li></ul><h3 id="3-11多序列比对的编辑和发布"><a href="#3-11多序列比对的编辑和发布" class="headerlink" title="3.11多序列比对的编辑和发布"></a>3.11多序列比对的编辑和发布</h3><p>对多序列比对结果进行彩色显示和手工编辑</p><ul><li><a href="http://www.jalview.org/">Jalview</a> </li><li>多序列比对美化工具</li></ul><img src="https://s1.ax1x.com/2020/04/15/Ji1SzV.png" alt="Ji1SzV.png" border="0" /><!--![Ji1SzV.png](https://s1.ax1x.com/2020/04/15/Ji1SzV.png)--><h3 id="3-12寻找保守区域"><a href="#3-12寻找保守区域" class="headerlink" title="3.12寻找保守区域"></a>3.12寻找保守区域</h3><p>一个重要的问题：我们在多序列比对中获得什么？</p><ul><li>答案是：保守区域</li></ul><h4 id="weblogo-序列标识图"><a href="#weblogo-序列标识图" class="headerlink" title="weblogo -序列标识图"></a>weblogo -序列标识图</h4><p>可用于把重复出现的字母变成某个字母的长度。</p><h4 id="MEME-序列基序"><a href="#MEME-序列基序" class="headerlink" title="MEME - 序列基序"></a>MEME - 序列基序</h4><h4 id="prints-指纹图谱数据库-蛋白质的功能与序列关系"><a href="#prints-指纹图谱数据库-蛋白质的功能与序列关系" class="headerlink" title="prints 指纹图谱数据库-蛋白质的功能与序列关系"></a>prints 指纹图谱数据库-蛋白质的功能与序列关系</h4><ul><li><p>prints 是蛋白质序列指纹图谱数据库，储存了目前已发现的绝大多数蛋白质家族的指纹图谱。对于一个陌生的蛋白质，只要看看它的序列是否符合某个家族的指纹图谱。一个陌生的蛋白质，只要看看它的序列是否符合某个家族的图谱就可以对他进行分类并预测它的功能。</p></li><li><p>一个蛋白质的指纹就是一组保守的序列基序，用于刻画蛋白质家族的特征。这些基序由多序列比对结果获得，且他们在氨基酸序列上是不相邻的，但是在三维结构中，他们可能紧密结合在一起。 </p></li><li><p><a href="http://www.bioinf.manchester.ac.uk/dbbrowser/PRINTS">prints</a></p></li><li><p>掌握序列比较的方法并学会分析它的结果，就可以把诸多看似零散的信息拼接成一个完整的魔方。</p></li></ul><h2 id="第四章：分子进化与系统发生树"><a href="#第四章：分子进化与系统发生树" class="headerlink" title="第四章：分子进化与系统发生树"></a>第四章：分子进化与系统发生树</h2><h3 id="4-1-进化的故事"><a href="#4-1-进化的故事" class="headerlink" title="4.1 进化的故事"></a>4.1 进化的故事</h3><ul><li>拉马克的用进废退和达尔文的进化论，达尔文的更适合解释生物进化现象。</li></ul><h3 id="4-2-基本概念"><a href="#4-2-基本概念" class="headerlink" title="4.2 基本概念"></a>4.2 基本概念</h3><ul><li>如何研究进化：<ul><li>一、生物化石；</li><li>二、比较形态学、比较解剖</li><li>三、分子进化：利用软件，从分子水平上（DNA、RNA、蛋白质序列）构建各种生物间的系统发生树。准确度依赖软件的优劣及参数的设置。</li></ul></li><li><h4 id="基本概念："><a href="#基本概念：" class="headerlink" title="基本概念："></a>基本概念：</h4><ol><li>DNA、RNA或蛋白质序列包含了物种的所有进化史信息；</li><li>分子钟理论：一个特定蛋白质的进化变异的速度在不同物种中是基本恒定的。即两个蛋白质的序列越相近，他们距离共同祖先就越近。</li></ol></li></ul><h4 id="不同的同源"><a href="#不同的同源" class="headerlink" title="不同的同源"></a>不同的同源</h4><ul><li>相似的序列来源有两种途径，一种是来源于共同祖先的相似序列，一种是来源于不同祖先的序列。意思就是，相似序列并不一定是同源序列。</li><li>同源分：<ul><li>直系同源：来源于同一物种的两个物种的相似序列。</li><li>旁系同源：可能会进化出新的与原来有关的功能。</li><li>异同源：通过水平基因转移。来源于共生或病毒侵染所产生的相似基因。</li></ul></li></ul><p>不可以说是同源性80%，只能说是相似性80%，会被人看不起。</p><h3 id="4-3-系统发生树（分子树）"><a href="#4-3-系统发生树（分子树）" class="headerlink" title="4.3 系统发生树（分子树）"></a>4.3 系统发生树（分子树）</h3><ul><li><p>意义：</p><ul><li>对于一个未知的基因或蛋白质序列，确定其亲缘关系最近的物种。</li><li>预测一个新的发现的基因或蛋白质的功能。（相似基因有相似功能）</li><li>有助于预测一个分子功能的走势。</li><li>追溯一个基因的起源。</li></ul></li><li><p>系统发生树的种类</p><ul><li>有根树：反应了树上基因或蛋白质进化的时间顺序，通过分析有根树的树枝的长度，可以了解不同的基因或蛋白质以什么方式和速度进化。</li><li>无根树：只反映分类单元之间的距离，而不涉及谁是谁的祖先问题。</li><li>做有根树需要指定一个外类群，就是你说研究之外的一类群，怎样就可以确定一个共同的祖先，确定一个根。</li></ul></li><li><p>物种树</p><ul><li>1998年伍斯构建了一个涵盖了整个生命界的系统树（物种树）十分庞大。  </li></ul></li><li><p>物种树与分子树</p><ul><li>物种树是基于整个基因组构建的。（比较粗）</li><li>分子树是基于不同物种里某个基因或蛋白质序列之间的关系构建的。（比较细）</li></ul></li></ul><h3 id="4-4-系统发生树的构建"><a href="#4-4-系统发生树的构建" class="headerlink" title="4.4 系统发生树的构建"></a>4.4 系统发生树的构建</h3><ul><li><p>方法：</p><ol><li>基于距离的方法（最快，最不精确）</li><li>最大简约法</li><li>最大自然法（最优）</li><li>贝叶斯推断法（最慢，最精确）</li></ol></li><li><p>软件：</p></li></ul><img src="https://s1.ax1x.com/2020/04/16/JAFwrR.png" alt="JAFwrR.png" border="0" /><!--![JAFwrR.png](https://s1.ax1x.com/2020/04/16/JAFwrR.png)-->如果要发表纯生物学的文章，要两种以上的方法得出一个结果才可以通过<ul><li>基于距离的UPGMA算法<ul><li>非加权分组平均法（UPGMA）</li><li>用序列间不同的碱基数目作为序列间的距离度量。 </li></ul></li></ul><p><a href="https://www.icourse163.org/learn/SDU-1001907001?tid=1450236461&from=study#/learn/content?type=detail&id=1214471868&cid=1218216678&replay=true">算法讲解</a></p><ul><li>用什么序列构建序列发生树？<ul><li>如果DNA 序列两两之间的一致度大于70%，就用DNA序列。</li><li>如果DNA序列两两之间的一致度小于70%的话，DNA序列和蛋白质序列都可以用。（一般用蛋白质序列）</li></ul></li></ul><h3 id="4-5-MEGA7构建系统发生树"><a href="#4-5-MEGA7构建系统发生树" class="headerlink" title="4.5 MEGA7构建系统发生树"></a>4.5 MEGA7构建系统发生树</h3><ul><li><p><a href="https://www.icourse163.org/learn/SDU-1001907001?tid=1450236461&from=study#/learn/content?type=detail&id=1214471869&cid=1218216680&replay=true">连接</a></p></li><li><p>免费、支持多操作系统、被业界认可</p></li><li><p>设置系统发生树的几个设置：</p><ul><li>test of Phylogeny : bootstrap method</li><li>Model/Method : p-distance </li><li>Gaps/Missing Data Treatment : <ul><li>Complete deletion（序列间不同残基的个数来作为度量单位的话）</li><li>partial deletion （部分删除，NG方法）</li></ul></li></ul></li></ul><img src="https://s1.ax1x.com/2020/04/16/JAYukT.png" alt="JAYukT.png" border="0" />- 树上的数字表示可信度- <h2 id="第五章：蛋白质结构的预测与分析"><a href="#第五章：蛋白质结构的预测与分析" class="headerlink" title="第五章：蛋白质结构的预测与分析"></a>第五章：蛋白质结构的预测与分析</h2><h3 id="5-1-蛋白质的结构"><a href="#5-1-蛋白质的结构" class="headerlink" title="5.1 蛋白质的结构"></a>5.1 蛋白质的结构</h3><p>意义，把蛋白质序列三维化</p><ul><li>蛋白质的结构<ul><li>一级结构：氨基酸序列</li><li>二级结构：周期性的结构构象，阿尔法螺旋、β折叠等</li><li>三级结构：整条多肽链的三维空间结构</li><li>四级结构：多个亚基形成的复合体结构，如三聚体、四聚体等</li></ul></li></ul><h3 id="5-2-蛋白质的二级结构"><a href="#5-2-蛋白质的二级结构" class="headerlink" title="5.2 蛋白质的二级结构"></a>5.2 蛋白质的二级结构</h3><ul><li>螺旋：常见的就是阿尔法螺旋。</li><li>β折叠：由β折片平行排列而成。</li><li>β转角：如果肽链发生了急转弯，这个转弯结构叫β转角。</li><li>无规则卷曲：无规则松山结构。</li><li>图形中<ul><li>E、黄色箭头：β折片结构</li><li>G、波浪线：螺旋结构</li><li>T、小鼓包：转角  </li><li>H、代表阿尔法螺旋</li><li>没有字母的结构就是松散的结构</li></ul></li></ul><img src="https://s1.ax1x.com/2020/04/19/Ju2nNq.png" alt="Ju2nNq.png" border="0" /><!--![Ju2nNq.png](https://s1.ax1x.com/2020/04/19/Ju2nNq.png)--><h4 id="DSSP（蛋白质二级结构词典）"><a href="#DSSP（蛋白质二级结构词典）" class="headerlink" title="DSSP（蛋白质二级结构词典）"></a>DSSP（蛋白质二级结构词典）</h4><p>DSSP并不预测二级结构，而是根据二级结构的定义对已经测定的三级结构的蛋白质的各个位置指认出是哪种二级结构。<strong>不能通过氨基酸序列得到DSSP文件（二级结构信息），只能是通过三级结构得到。</strong><br><a href="http://swift.cmbi.ru.nl/gv/dssp">DSSP网址</a></p><ul><li>一般数据库不提供二级结构的文件（DSSP), PDB中有ss.txt的文件（储存有一级、二级总的结构），可以下载。</li></ul><h4 id="蛋白质二级结构的预测"><a href="#蛋白质二级结构的预测" class="headerlink" title="蛋白质二级结构的预测"></a>蛋白质二级结构的预测</h4><ul><li>对于未知的结构的蛋白质，可以通过氨基酸序列，预测其二级结构。</li></ul><img src="https://s1.ax1x.com/2020/04/19/Juh4Fs.png" alt="Juh4Fs.png" border="0" /><!--![Juh4Fs.png](https://s1.ax1x.com/2020/04/19/Juh4Fs.png)--><ul><li>一般邮箱只能是学生邮箱，教育的邮箱，其他的商业邮箱不行。</li></ul><h3 id="5-3-蛋白质的三级结构"><a href="#5-3-蛋白质的三级结构" class="headerlink" title="5.3 蛋白质的三级结构"></a>5.3 蛋白质的三级结构</h3><ul><li>蛋白质结构的测定方法<ul><li>X射线衍射法（主要测定方法，能结晶的蛋白质）</li><li>核磁共振法（不能结晶的蛋白质，测定质量很小）</li><li>冷冻电子显微镜法（价格高）</li></ul></li><li>PDB文件是通过存储每一个原子的3D坐标来存储蛋白质的空间结构的。这些坐标可以被三维可视化的软件读取，并展示出来。</li><li>蛋白质三维可视化软件：<ul><li>VMD（与Pymol差点，但免费）</li><li>Maestro</li><li>Pymol（优秀，但收费）</li></ul></li></ul><h3 id="5-4-三维可视化软件-VMD"><a href="#5-4-三维可视化软件-VMD" class="headerlink" title="5.4 三维可视化软件 VMD"></a>5.4 三维可视化软件 VMD</h3><ul><li>第一节讲了些文件的导入和鼠标的使用。（菜单栏上都有）</li><li>第二节Graphical(绘图的)，里面能更改蛋白质的显示效果_<a href="https://www.icourse163.org/learn/SDU-1001907001?tid=1450236461#/learn/content?type=detail&id=1214471876&cid=1218216701">连接</a></li><li>第三节multiple representations</li></ul><h3 id="5-5-计算方法预测三级结构"><a href="#5-5-计算方法预测三级结构" class="headerlink" title="5.5 计算方法预测三级结构"></a>5.5 计算方法预测三级结构</h3><p>实验三高问题：材料要求高、实验仪器造价高、实验耗时高</p><h4 id="计算方法："><a href="#计算方法：" class="headerlink" title="计算方法："></a>计算方法：</h4><ul><li>从头计算法</li><li>同源建模法（首选）</li><li>穿线法</li><li>综合法</li></ul><h4 id="同源建模法-SWISS-MODLE："><a href="#同源建模法-SWISS-MODLE：" class="headerlink" title="同源建模法 SWISS-MODLE："></a>同源建模法 SWISS-MODLE：</h4><p>相似的氨基酸序列对应着相似的蛋白质结构</p><p><a href="https://swissmodel.expasy.org/">网址链接</a></p><ol><li>找到与目标序列同源的已知结构作为模板（一致度&gt;30%)</li><li>目标序列与模板序列创建序列比对，通常软件自动创建的序列比对还要工校对。</li><li>根据第二步创建的序列比对，用同源软件预测结果模型。</li><li>评估模型质量，并根据评估结果重复以上过程，直到模型质量合格。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 生物信息学 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>R语言与数据分析（三）</title>
      <link href="2020/06/26/r-shu-ju-fen-xi/r-yu-yan-ru-men-yu-shu-ju-fen-xi-bi-ji-san/"/>
      <url>2020/06/26/r-shu-ju-fen-xi/r-yu-yan-ru-men-yu-shu-ju-fen-xi-bi-ji-san/</url>
      
        <content type="html"><![CDATA[<blockquote class="blockquote-center">喜欢一件事就去争取吧。</blockquote><a id="more"></a><h2 id="48-相关性检验函数"><a href="#48-相关性检验函数" class="headerlink" title="48-相关性检验函数"></a>48-相关性检验函数</h2><p>在计算好相关性系数之后就可以进行统计学的显著性检验</p><p>需要量化才能证明两个系数的相关性</p><p>还是之前的例子,检测下文盲率和谋杀率之间的关系</p><pre><code class="r">&gt; library(ggm)&gt; ?cor.test&gt; cor.test(state.x77[,3],state.x77[,5])    Pearson&#39;s product-moment correlationdata:  state.x77[, 3] and state.x77[, 5]t = 6.8479, df = 48, p-value = 1.258e-08  ## 这里是小于0.05的,说明相关alternative hypothesis: true correlation is not equal to 095 percent confidence interval:  ## 这是是置信区间,是统计学中重要的概念 0.5279280 0.8207295sample estimates:      cor 0.7029752  ## 这是是相关系数</code></pre><h3 id="置信区间"><a href="#置信区间" class="headerlink" title="置信区间"></a>置信区间</h3><p>置信区间: confidence interval,是指由样本统计量所构造的总体参数的估计区间。在统计学中,一个概率样本的置信区间是对这个样本的某个总体参数的区间估计。置信区间展现的是这个参数的真实值有一定概率落在测量结果的周围的程度。置信区间给出的是被测量参数的测量值的可信程度。</p><p>简单的说就是,光给出概率不行,还得给出概率发生的范围.</p><p>psych 包中的 corr.test可以一次性计算多个变量之间的计算</p><pre><code class="r">&gt; corr.test(state.x77)  ## 这里我的电脑加载不来</code></pre><p>pcor.test 可用于偏相关的检验</p><pre><code class="r">&gt; x = pcor(c(1,5,2,3,6),cov(state.x77))## 参数依次为,偏相关系数,控制的变量数,样本数## 2,3,6三个变量,总共50个州&gt; pcor.test(x,3,50)$tval  ## 学生t检验统计[1] 2.476049$df  ## 自由度[1] 45$pvalue  ## p值[1] 0.01711252</code></pre><p>分组数据的相关性检验,差异发生的概率,从而比较两个平均数的差异是否显著,主要用于样本含量小,一般小于30个的,总体标准差未知的正太分布数据.</p><h3 id="t检验"><a href="#t检验" class="headerlink" title="t检验"></a>t检验</h3><pre><code class="r">## 格式为 y~x,其中的y是一个数值型变量，x是一个二分型的变量&gt; ?t.test()&gt; library(MASS)&gt; t.test(Prob ~ So,data = UScrime)    Welch Two Sample t-testdata:  Prob by Sot = -3.8954, df = 24.925, p-value = 0.0006506alternative hypothesis: true difference in means is not equal to 095 percent confidence interval: -0.03852569 -0.01187439sample estimates:mean in group 0 mean in group 1      0.03851265      0.06371269 &gt;</code></pre><h3 id="非参数检验-方差未知"><a href="#非参数检验-方差未知" class="headerlink" title="非参数检验 方差未知"></a>非参数检验 方差未知</h3><p>非参数检验,在总体方差未知或知道甚少的情况下,利用样本数据对总体分布形态等进行推断的方法。由于非参数检验方法在推断过程中不涉及有关总体分布的参数,因而得名为”非参数”检验</p><h3 id="参数检验"><a href="#参数检验" class="headerlink" title="参数检验"></a>参数检验</h3><p>参数检验,是在<strong>总体分布形式已知</strong>的情况下,对总体分布的参数如均值、方差等进行推断的方法。也就是数据分布已知比如满足正态分布。</p><h2 id="49-绘图函数"><a href="#49-绘图函数" class="headerlink" title="49-绘图函数"></a>49-绘图函数</h2><p>R中四大作图函数</p><ol><li>基础绘图函数（graphics）默认加载</li><li>lattice包</li><li>ggplot2包</li><li>grid包</li></ol><h3 id="基础绘图包"><a href="#基础绘图包" class="headerlink" title="基础绘图包"></a>基础绘图包</h3><p>常用的函数</p><ul><li>arrows 箭头函数</li><li>hist 直方图</li><li>stars 形状图</li><li>pie 饼图</li><li>polygon 多边形图</li></ul><p>查看展示内容</p><pre><code class="r">&gt; demo(graphics)</code></pre><p>R基础绘图系统分高级绘图和低级绘图，高级绘图可以一步到位。</p><ul><li>散点图：x和y两个坐标数据</li><li>直方图：因子</li><li>热力图：数据矩阵</li><li>要做到看到一个图形就能知道是用那个数据，那个函数做出来</li></ul><pre><code class="r">&gt; plot(women)</code></pre><p>R中的S3系统指属性，泛型函数，方法</p><pre><code class="r">&gt; methods(plot)&gt; methods(summary)</code></pre><h3 id="par函数"><a href="#par函数" class="headerlink" title="par函数"></a>par函数</h3><p>par可以对绘图函数进行设置</p><pre><code class="r">&gt; plot(as.factor(mtcars$cyl),col = c(&quot;red&quot;,&quot;green&quot;,&quot;blue&quot;))</code></pre><!--<img src="https://s1.ax1x.com/2020/06/10/t7QYrj.png" alt="t7QYrj.png" border="0" />--><p><img src="https://s1.ax1x.com/2020/06/10/t7QYrj.png" alt="t7QYrj.png"></p><h2 id="50-自定义函数"><a href="#50-自定义函数" class="headerlink" title="50-自定义函数"></a>50-自定义函数</h2><p>编写函数就是为了减少重复代码的书写</p><p>在R中直接数据函数名，不输入括号就能直接看到源代码</p><h3 id="函数名称"><a href="#函数名称" class="headerlink" title="函数名称"></a>函数名称</h3><ol><li>函数命名与功能相关</li><li>可以是字母和数字的组合，但必须是字母开头</li></ol><p>一些编程知识</p><h2 id="51-R数据分析实战"><a href="#51-R数据分析实战" class="headerlink" title="51-R数据分析实战"></a>51-R数据分析实战</h2><ul><li>小麦产量案例</li><li>药物实验</li><li>社会科学，失业率，犯罪率，</li><li>量化投资产业</li><li>一些反面的教材</li></ul><h2 id="52-线性回归（一）"><a href="#52-线性回归（一）" class="headerlink" title="52-线性回归（一）"></a>52-线性回归（一）</h2><p>回归regression ,通常指那些用一个或多个预测变量,也称自变量或解释变量,来预测响应变量,也称为因变量、效标变量或结果变量的方法。</p><p>通过解释变量来预测响应变量</p><p>人话就是根据很多数据的规律，找到这个数据改在的地方，回归到它本来的地方，</p><h3 id="回归案例"><a href="#回归案例" class="headerlink" title="回归案例"></a>回归案例</h3><ol><li>锻炼时间与消耗卡路里之间是什么关系?</li><li>是直线关系还是曲线关系?</li><li>卡路里消耗到某个点后,锻炼是否还有效果?</li><li>对年轻人和老人影响一致吗?</li><li>对男性和女性影响一致吗?</li><li>对肥胖的人和苗条的人影响一致吗?</li></ol><h3 id="回归分析类型"><a href="#回归分析类型" class="headerlink" title="回归分析类型"></a>回归分析类型</h3><!--<img src="https://s1.ax1x.com/2020/06/10/t7aYVS.png" alt="t7aYVS.png" border="0" />--><p><img src="https://s1.ax1x.com/2020/06/10/t7aYVS.png" alt="t7aYVS.png"></p><h4 id="R表达式中常用的符号"><a href="#R表达式中常用的符号" class="headerlink" title="R表达式中常用的符号"></a>R表达式中常用的符号</h4><!--<img src="https://s1.ax1x.com/2020/06/10/t7des0.png" alt="t7des0.png" border="0" />--><p><img src="https://s1.ax1x.com/2020/06/10/t7des0.png" alt="t7des0.png"></p><h3 id="普通最小而成回归法"><a href="#普通最小而成回归法" class="headerlink" title="普通最小而成回归法"></a>普通最小而成回归法</h3><pre><code class="r">&gt; ?lm&gt; fit = lm(data = women,weight~height)&gt; fitCall:lm(formula = weight ~ height, data = women)Coefficients:  ## 第一个为截距值，第二个是系数值(Intercept)       height       -87.52         3.45 &gt; summary(fit)Call:  ## 这里列出回归的公式lm(formula = weight ~ height, data = women) Residuals:  ## 残差,真实值和预测值之间的差，如果残差全是0，那就是线性方程    Min      1Q  Median      3Q     Max -1.7333 -1.1333 -0.3833  0.7417  3.1167 Coefficients:  ## 系数项，intrecept为截距项，Estimate是系数             Estimate Std. Error t value Pr(&gt;|t|)   ## 这里的pr就是p值(Intercept) -87.51667    5.93694  -14.74 1.71e-09 ***height        3.45000    0.09114   37.85 1.09e-14 ***---Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1Residual standard error: 1.525 on 13 degrees of freedomMultiple R-squared:  0.991,    Adjusted R-squared:  0.9903   ## 表示这个模型课程解释多少比例的数据F-statistic:  1433 on 1 and 13 DF,  p-value: 1.091e-14  ## F统计量，p值来衡量，越小越好，越显著。大于0.05时不适用</code></pre><h2 id="53-线性回归（二）"><a href="#53-线性回归（二）" class="headerlink" title="53-线性回归（二）"></a>53-线性回归（二）</h2><p>线性回归常用函数</p><!--<img src="https://s1.ax1x.com/2020/06/10/t7DVtU.png" alt="t7DVtU.png" border="0" />--><p><img src="https://s1.ax1x.com/2020/06/10/t7DVtU.png" alt="t7DVtU.png"></p><pre><code class="r">&gt; plot(fit)</code></pre><p>会生成四幅图,分别时残差拟合图,正太QQ图,大小位列图,残差影响图</p><pre><code class="r">&gt; plot(women)&gt; abline(fit)  ## 这样就可以在原图上画出回归直线,abline只适用于直线</code></pre><h3 id="多项式回归-可以更好的拟合数据"><a href="#多项式回归-可以更好的拟合数据" class="headerlink" title="多项式回归,可以更好的拟合数据"></a>多项式回归,可以更好的拟合数据</h3><p>注意公式,</p><p>至于什么时候加,要根据你自己对数据的理解不断尝试,</p><pre><code class="r">&gt; fit2 = lm(data = women,weight~height+I(height^2))&gt; fit2&gt; summary(fit2)  ## 其中的解释更好&gt; plot(women)&gt; abline(fit)## 第一个参数时横坐标的数值,第二个参数时根据拟合曲线得出的对应值&gt; lines(women$height,fitted(fit2),col = &quot;red&quot;) </code></pre><!--<img src="https://s1.ax1x.com/2020/06/11/t7s3WD.png" alt="t7s3WD.png" border="0" />--><p><img src="https://s1.ax1x.com/2020/06/11/t7s3WD.png" alt="t7s3WD.png"></p><h2 id="54-多元线性回归"><a href="#54-多元线性回归" class="headerlink" title="54-多元线性回归"></a>54-多元线性回归</h2><p>当预测变量不止一个时，就变成了多元线性回归，相当于求解多元方程，难得时有些变量权重不一样，有些很大有些很小</p><pre><code class="r">&gt; fir = lm(data = states,Murder ~ Population+Illiteracy+Income+Frost)&gt; summary(fir)Call:lm(formula = Murder ~ Population + Illiteracy + Income + Frost,     data = states)Residuals:    Min      1Q  Median      3Q     Max -4.7960 -1.6495 -0.0811  1.4815  7.6210 Coefficients:             Estimate Std. Error t value Pr(&gt;|t|)    (Intercept) 1.235e+00  3.866e+00   0.319   0.7510    Population  2.237e-04  9.052e-05   2.471   0.0173 *  Illiteracy  4.143e+00  8.744e-01   4.738 2.19e-05 ***  ## 可以看到与文盲率相关性很大Income      6.442e-05  6.837e-04   0.094   0.9253    Frost       5.813e-04  1.005e-02   0.058   0.9541    ---Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1Residual standard error: 2.535 on 45 degrees of freedomMultiple R-squared:  0.567,    Adjusted R-squared:  0.5285 F-statistic: 14.73 on 4 and 45 DF,  p-value: 9.133e-08## 根据系数项和截距项就可以写出方程&gt; coef(fir) (Intercept)   Population   Illiteracy       Income        Frost 1.2345634112 0.0002236754 4.1428365903 0.0000644247 0.0005813055     </code></pre><h3 id="逐步回归"><a href="#逐步回归" class="headerlink" title="逐步回归"></a>逐步回归</h3><p>多个模型之间的关系,一次添加一个或者减少一个,直到模型不变</p><h2 id="55-回归诊断"><a href="#55-回归诊断" class="headerlink" title="55-回归诊断"></a>55-回归诊断</h2><p>诊断要做的</p><ul><li>这个模型是否是最佳模型？</li><li>模型多大程度满足OLS模型的统计假设?</li><li>模型是否经得起更多数据的检验?</li><li>如果拟合出来的模型指标不好,该如何继续下去?</li></ul><h3 id="满足OLS模型统计-只有满足这些条件才可以用lm函数进行拟合"><a href="#满足OLS模型统计-只有满足这些条件才可以用lm函数进行拟合" class="headerlink" title="满足OLS模型统计,只有满足这些条件才可以用lm函数进行拟合"></a>满足OLS模型统计,只有满足这些条件才可以用lm函数进行拟合</h3><ol><li>正态性:对于固定的自变量值,因变量值成正态分布。</li><li>独立性:因变量之间相互独立。</li><li>线性:因变量与自变量之间为线性相关</li><li>同方差性:因变量的方差不随自变量的水平不同而变化。也可称作不变方差。</li></ol><p>分别时残差拟合图,正太QQ图,大小位列图,残差影响图,查阅资料看下这些图的作用</p><pre><code class="r">&gt; fit = lm(data = women, weight~height)&gt; par(mfrow=c(2,2))  ## 同时显示四幅图&gt; plot(fit)## 出来的四幅图就是来评价这些条件的</code></pre><h3 id="抽样法验证"><a href="#抽样法验证" class="headerlink" title="抽样法验证"></a>抽样法验证</h3><ol><li>数据集中有1000个样本,随机抽取500个数据进行回归分析;</li><li>模型建好之后,利用predict函数,对剩余500个样本进行预测,比较残差值;श,接入入採人人</li><li>如果预测准确,说明模型可以,否则就需要调整模型。</li></ol><h2 id="56-方差分析-一"><a href="#56-方差分析-一" class="headerlink" title="56-方差分析(一)"></a>56-方差分析(一)</h2><p>方差分析,称为Analysis of Variance ,简称ANOVA,也称为“变异数分析” ,用于两个及两个以上样本均数差别的显著性检验。从广义上来讲,方差分析也属于回归分析的一种。只不过线性回归的因变量一般是连续型变量。而当自变量是因子时,研究关注的重点通常会从预测转向不同组之间差异的比较。这就是方差分析。</p><h3 id="R中因子的应用"><a href="#R中因子的应用" class="headerlink" title="R中因子的应用"></a>R中因子的应用</h3><ul><li>计算频数</li><li>独立性检验</li><li>相关性检验</li><li>方差分析</li><li>主成分分析</li><li>因子分析</li></ul><h3 id="方差分析的种类"><a href="#方差分析的种类" class="headerlink" title="方差分析的种类"></a>方差分析的种类</h3><ol><li>单因素方差分析ANOVA (组内,组间)</li><li>双因素方差分析ANOVA</li><li>协方差分析ANCOVA</li><li>多元方差分析MANOVA</li><li>多元方差分析MANCOVA</li></ol><h3 id="顺序很重要"><a href="#顺序很重要" class="headerlink" title="顺序很重要"></a>顺序很重要</h3><!--<img src="https://s1.ax1x.com/2020/06/11/tbFPCd.png" alt="tbFPCd.png" border="0" />--><p><img src="https://s1.ax1x.com/2020/06/11/tbFPCd.png" alt="tbFPCd.png"></p><h2 id="57-方差分析-二"><a href="#57-方差分析-二" class="headerlink" title="57-方差分析(二)"></a>57-方差分析(二)</h2><p>方差发案例,方差分析主要是看F值和P值</p><h3 id="单因素方差分析"><a href="#单因素方差分析" class="headerlink" title="单因素方差分析"></a>单因素方差分析</h3><p>降低胆固醇药物的五种治疗方法的数据</p><p>没听懂,这里老师讲的莫名其妙的,可以查资料寻找方法</p><h3 id="协方差分析"><a href="#协方差分析" class="headerlink" title="协方差分析"></a>协方差分析</h3><pre><code class="r">&gt; ?litter&gt; attach(litter)## 因变量werght,协变量gesttime,自变量dose&gt; fit3 = avo(weight ~ gesttime+dose,data = litter)&gt; summary(fit3)            Df Sum Sq Mean Sq F value  Pr(&gt;F)   gesttime     1  134.3  134.30   8.049 0.00597 **  ## 怀孕时间,和体重dose         3  137.1   45.71   2.739 0.04988 *   ## 计量与体重Residuals   69 1151.3   16.69                   ---Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1</code></pre><h3 id="双因素分析案例"><a href="#双因素分析案例" class="headerlink" title="双因素分析案例"></a>双因素分析案例</h3><p>橙汁和维生素c的为食,60只豚鼠,牙齿的生长</p><pre><code class="r">&gt; ?ToothGrowth&gt; attach(ToothGrowth)&gt; xtabs(~supp+dose)    dosesupp 0.5  1  2  OJ  10 10 10  VC  10 10 10&gt; dose1 = factor(ToothGrowth$dose)  ## 讲dose转化为因子&gt; fit = aov(data = ToothGrowth,len~supp*dose1)&gt; summary(fit)            Df Sum Sq Mean Sq F value   Pr(&gt;F)    supp         1  205.4   205.4  15.572 0.000231 ***  ## 说明为食方法对牙齿的生长有影响,dose1        2 2426.4  1213.2  92.000  &lt; 2e-16 ***## 说明为食计量对牙齿的生长也有影响supp:dose1   2  108.3    54.2   4.107 0.021860 *  Residuals   54  712.1    13.2                     ---Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1</code></pre><p>看不懂列的公式了,,,</p><h2 id="58-功效分析"><a href="#58-功效分析" class="headerlink" title="58-功效分析"></a>58-功效分析</h2><p>在这里条论下数据分析中应该使用多少的样本,如果样本少,p值小也是不可信.</p><p>在给定的置信度和概率下计算出所要的样本量,这就是功效分析了</p><p>功效分析, power analysis ,可以帮助在给定置信度的情况下,判断检测到给定效应值时所需的样本量。反过来,它也可以在给定置信度水平情况下,计算在某样本量内能检测到给定效应值的概率。</p><h3 id="功效分析函数"><a href="#功效分析函数" class="headerlink" title="功效分析函数"></a>功效分析函数</h3><!--<img src="https://s1.ax1x.com/2020/06/11/tbaR2j.png" alt="tbaR2j.png" border="0" />--><p><img src="https://s1.ax1x.com/2020/06/11/tbaR2j.png" alt="tbaR2j.png"></p><h3 id="功效分析理论基础"><a href="#功效分析理论基础" class="headerlink" title="功效分析理论基础"></a>功效分析理论基础</h3><!--<img src="https://s1.ax1x.com/2020/06/11/tbajMR.png" alt="tbajMR.png" border="0" />--><p><img src="https://s1.ax1x.com/2020/06/11/tbajMR.png" alt="tbajMR.png"><br>I型错误就是假阳性,II型错误就是假阴性</p><ol><li>样本大小指的是实验设计中每种条件/组中观测的数目。</li><li>显著性水平(也称为alpha)由型错误的概率来定义。也可以把它看做是发现效应不发生的概率。</li><li>功效通过减去1型错误的概率来定义。我们可以把它看做是真实效应发生的概率。</li><li>效应值指的是在备择或研究假设下效应的量。效应值的表达式依赖于假设检验中使用的统计方法。</li></ol><h3 id="给出任意三种就可以推算第四种"><a href="#给出任意三种就可以推算第四种" class="headerlink" title="给出任意三种就可以推算第四种"></a>给出任意三种就可以推算第四种</h3><!--<img src="https://s1.ax1x.com/2020/06/11/tbwwHP.png" alt="tbwwHP.png" border="0" />--><p><img src="https://s1.ax1x.com/2020/06/11/tbwwHP.png" alt="tbwwHP.png"></p><h3 id="线性回归功效的案例"><a href="#线性回归功效的案例" class="headerlink" title="线性回归功效的案例"></a>线性回归功效的案例</h3><p>假设显著性在0.05,那么在90%的置信度的情况下,需要多少的受试者才能得到这样方差</p><h4 id="pwr包"><a href="#pwr包" class="headerlink" title="pwr包"></a>pwr包</h4><p>pwr.f2.test,U为分子自由度,V为分母自由度,f2是效应值,sig.level为显著水平,power为功效水平</p><pre><code class="r">&gt; library(pwr)&gt; pwr.f2.test(u=3,sig.level = 0.05,power = 0.9,f2 = 0.0769)     Multiple regression power calculation               u = 3              v = 184.2426             f2 = 0.0769      sig.level = 0.05          power = 0.9</code></pre><h3 id="方差分析功效分析案例"><a href="#方差分析功效分析案例" class="headerlink" title="方差分析功效分析案例"></a>方差分析功效分析案例</h3><p>一个单因素方差分析,要达到0.9的功效,效应值为0.25,0.05的显著水平,计算每组的样本量</p><p>pwr.anova.test  其中k为组的个数,n是各组的样本大小,也是要求的量,f是效应值</p><pre><code>## 分两组,每组85个样本&gt; pwr.anova.test(k=2,f=0.25,sig.level = 0.05,power = 0.9)     Balanced one-way analysis of variance power calculation               k = 2              n = 85.03128              f = 0.25      sig.level = 0.05          power = 0.9NOTE: n is number in each group</code></pre><h2 id="59-广义线性模型"><a href="#59-广义线性模型" class="headerlink" title="59-广义线性模型"></a>59-广义线性模型</h2><p>在自己应用中很多数据都是无规则分布的,要通过分析来找到规律</p><p>线性回归和方差分析都是基于正态分布的假设,广义线性模型扩展了线性模型的框架,它包含了非正态因变量的分析。</p><p>可以用glm进行广义线性回归分析,与lm类似</p><p>glm函数中重要的概率分布函数family,和相应的连接函数faction</p><p>广义线性的拟合</p><p>可用于的分布</p><ul><li>binomial(link = “logit”)  二分项分布</li><li>gaussian(link = “identity”)</li><li>Gamma(link = “inverse”)  </li><li>inverse.gaussian(link = “1/mu^2”)</li><li>poisson(link = “log”)</li><li>quasi(link = “identity”, variance = “constant”)</li><li>quasibinomial(link = “logit”)</li><li>quasipoisson(link = “log”)</li></ul><h3 id="泊松回归"><a href="#泊松回归" class="headerlink" title="泊松回归"></a>泊松回归</h3><p>泊松回归是用来为计数资料和列联表建模的一种回归分析。泊松回归假设因变量是泊松分布,并假设它平均值的对数可被未知参数的线性组合建模。</p><p>泊松分布可用于什么?</p><p>这里对一个癫痫病的年龄和发病率之间的数据</p><pre><code class="r">&gt; ?glm&gt; data(breslow.dat,package = &quot;robust&quot;)  ## 加载数据集&gt; attach(breslow.dat)  ## 获取这个数据集&gt; fit4 = glm(data = breslow.dat,family = poisson(link = &quot;log&quot;,sumY~Base+Trt+Age))  ## sumY为因变量&gt; summary(fit4)Call:glm(formula = sumY ~ Base + Trt + Age, family = poisson(link = &quot;log&quot;),     data = breslow.dat)Deviance Residuals:     Min       1Q   Median       3Q      Max  -6.0569  -2.0433  -0.9397   0.7929  11.0061  Coefficients:               Estimate Std. Error z value Pr(&gt;|z|)(Intercept)   1.9488259  0.1356191  14.370  &lt; 2e-16Base          0.0226517  0.0005093  44.476  &lt; 2e-16Trtprogabide -0.1527009  0.0478051  -3.194   0.0014Age           0.0227401  0.0040240   5.651 1.59e-08(Intercept)  ***Base         ***Trtprogabide ** Age          ***---Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1(Dispersion parameter for poisson family taken to be 1)    Null deviance: 2122.73  on 58  degrees of freedomResidual deviance:  559.44  on 55  degrees of freedomAIC: 850.71Number of Fisher Scoring iterations: 5&gt; coef(fit4)  ## 显示个变量的系数,这里的截距没意义一 (Intercept)         Base Trtprogabide          Age   1.94882593   0.02265174  -0.15270095   0.02274013 &gt; exp(coef(fit4))  ## 因为是对数,取指数才与因变量成正比 (Intercept)         Base Trtprogabide          Age    7.0204403    1.0229102    0.8583864    1.0230007  ## 这里相等于年龄长一岁,期望的癫痫病发病率将乘以1.023</code></pre><h2 id="60-Logistic回归"><a href="#60-Logistic回归" class="headerlink" title="60-Logistic回归"></a>60-Logistic回归</h2><p>当通过一系列连续型或类别型预测变量来预测二值型结果变量时Logistic回归是一个非常有用的工具。</p><h3 id="logistic回归案例"><a href="#logistic回归案例" class="headerlink" title="logistic回归案例"></a>logistic回归案例</h3><p>根据危险因素预测某疾病发生的概率。例如,想探讨胃癌发生的危险因素,可以选择两组人群,一组是胃癌组,一组是非胃癌组,两组人群肯定有不同的体征和生活方式等。这里的因变量就是是否胃癌,即”是”或“否” ,为两分类变量,自变量就可以包括很多了,例如年龄、性别.饮食习惯、幽门螺杆菌感染等。自变量既可以是连续的,也可以是分类的。通过logistic回归分析,就可以大致了解到底哪些因素是胃癌的危险因素</p><p>出轨数据集</p><pre><code class="r">&gt; ?Affairs&gt; data(&quot;Affairs&quot;,package = &quot;AER&quot;)&gt; summary(Affairs)</code></pre><p>老师操作猛如虎,,,看不懂</p><h2 id="61-主成分分析"><a href="#61-主成分分析" class="headerlink" title="61-主成分分析"></a>61-主成分分析</h2><p>就是把很多不相干的数据去除,,降维处理</p><h3 id="主成分分析"><a href="#主成分分析" class="headerlink" title="主成分分析"></a>主成分分析</h3><p>主成分分析, Principal Component Analysis,也简称为PCA,是一种数据降维技巧,它能将大量相关变量转化为一组很少的不相关变量,这些无关的变量称为主成分。主成分其实是对原始变量重新进行线性组合将原先众多具有一定相关性的指标,重新组合为一组的新的相互独立的综合指标。</p><p>相当于聚类,有联系的聚在一组,成为独立的一簇</p><p>相关性最大的为Pc1,第二的为a1x1,第三的为a2x2,,,a_k*X_k</p><h3 id="R中自带的princomp可以进行主成分分析"><a href="#R中自带的princomp可以进行主成分分析" class="headerlink" title="R中自带的princomp可以进行主成分分析"></a>R中自带的princomp可以进行主成分分析</h3><pre><code class="r">&gt; ?princomp&gt; </code></pre><h3 id="利用pshch中的"><a href="#利用pshch中的" class="headerlink" title="利用pshch中的"></a>利用pshch中的</h3><h3 id="主成分分析与因子分析步骤"><a href="#主成分分析与因子分析步骤" class="headerlink" title="主成分分析与因子分析步骤"></a>主成分分析与因子分析步骤</h3><ol><li>数据预处理;</li><li>选择分析模型;</li><li>判断要选择的主成分/因子数目;  ## 通过绘制碎石图</li><li>选择主成分烟子;</li><li>旋转主成分/因子;</li><li>解释结果;</li><li>计算主成分或因子得分。这步也是可选的。</li></ol><h3 id="对USJudgeRationgs数据集的预测"><a href="#对USJudgeRationgs数据集的预测" class="headerlink" title="对USJudgeRationgs数据集的预测"></a>对USJudgeRationgs数据集的预测</h3><!--<img src="https://s1.ax1x.com/2020/06/11/tqWhTg.png" alt="tqWhTg.png" border="0" />--><p><img src="https://s1.ax1x.com/2020/06/11/tqWhTg.png" alt="tqWhTg.png"></p><ol><li>数据不需要处理了</li><li>PCA分析</li><li>判断要选择的主成分数目<pre><code class="r">&gt; library(psych)&gt; fa.parallel(USJudgeRatings,fa = &quot;pc&quot;,n.iter = 100)</code></pre></li></ol><p>碎石图什么原理,可以取研究下平行分析法</p><!--<img src="https://s1.ax1x.com/2020/06/11/tqhAvq.png" alt="tqhAvq.png" border="0" />--><p><img src="https://s1.ax1x.com/2020/06/11/tqhAvq.png" alt="tqhAvq.png"></p><p>我的包加载不出来,奇怪的很</p><pre><code class="r">&gt; pc = principal(USJudgeRatings,nfactors = 1,rotate = &quot;none&quot;,scores = FALSE)</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据分析 </category>
          
          <category> R语言数据分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>R语言与数据分析（二）</title>
      <link href="2020/06/26/r-shu-ju-fen-xi/r-yu-yan-ru-men-yu-shu-ju-fen-xi-bi-ji-er/"/>
      <url>2020/06/26/r-shu-ju-fen-xi/r-yu-yan-ru-men-yu-shu-ju-fen-xi-bi-ji-er/</url>
      
        <content type="html"><![CDATA[<blockquote class="blockquote-center">喜欢一件事就去争取吧。</blockquote><a id="more"></a><h2 id="34-数据转换"><a href="#34-数据转换" class="headerlink" title="34-数据转换"></a>34-数据转换</h2><p>数据的收集和存储已经会了,这里开始数据的转换,转换后就可以分析数据了.</p><p>前面介绍是向量,矩阵,数组,数据框,列表,因子,时间序列,等的增删改查</p><pre><code class="r">&gt; cars32 = read.csv(&quot;mtcars.csv&quot;)&gt; is.data.frame(cars32)[1] TRUE  ## 表示是一个矩阵&gt; is.data.frame(state.x77)[1] FALSE</code></pre><p>转换为数据框</p><pre><code class="r">&gt; dstate.x77 = as.data.frame(state.x77)</code></pre><p>转换为矩阵,变为字符串类型的矩阵</p><pre><code class="r">&gt; as.matrix(data.frame(state.region,state.x77))</code></pre><p>methods查看内容</p><pre><code class="r">&gt; methods(is)&gt; methods(as)</code></pre><h4 id="向量是R种基本的数据类型-加上一个维度就是数组或者矩阵"><a href="#向量是R种基本的数据类型-加上一个维度就是数组或者矩阵" class="headerlink" title="向量是R种基本的数据类型,加上一个维度就是数组或者矩阵"></a>向量是R种基本的数据类型,加上一个维度就是数组或者矩阵</h4><pre><code class="r">## &gt; is.data.frame(state.x77)[1] FALSE&gt; x = state.abb&gt; dim(x) = c(5,10)## 向量变因子&gt; x = state.babb&gt; as.factor(x)## 变为列表&gt; as.list(x)</code></pre><p>添加一个数据框</p><pre><code class="r">&gt; state = data.frame(x,state.region,state.x77)</code></pre><h2 id="35-数据转换-二"><a href="#35-数据转换-二" class="headerlink" title="35-数据转换(二)"></a>35-数据转换(二)</h2><p>讲一个取子集的操作</p><pre><code class="r">## 这是一个数据框&gt; who = read.csv(&quot;WHO.csv&quot;,header = T)&gt; who1 = who[c(1:50),c(1:10)]&gt; who2 = who[c(1,3,5,8),c(2,14,16)]</code></pre><p>取出CountryID 在50到100的国家,似乎不知道怎么去理解</p><pre><code class="r">&gt; who4 = who[which,(who$CountryID &gt; 50 &amp; who$CountryID &lt;=100)]&gt; who4 = subset(who,who$CountryID &gt; 50 &amp; who$CountryID &lt;=100)</code></pre><p>sample抽样,机器学习中抽取两份样本,一份用来建模,一份用来验证模型的有效性</p><pre><code class="r">&gt; ?sample## 例子,第一个参数为是选择那个向量,第二个是要抽取的个数,replace 表示是否放回式的抽样.&gt; x = 1:100&gt; sample(x,30,replace = T) [1] 39 23 11 26 50 86 86 71 26  6 10 93 81 73 74 87 98[18]  6 17 87 10 69 51 24 22 70 33 68 97 82&gt; sort(sample(x,30,replace = T)) [1]  8 19 23 23 28 31 32 40 40 42 50 50 50 51 52 55 58[18] 60 63 70 73 77 78 83 83 84 85 89 93 96</code></pre><p>sample对数据框进行抽样,取子集</p><pre><code class="r">&gt; who[sample(who$CountryID,30,replace = F),]</code></pre><p>删除固定行的数据</p><pre><code class="r">## 注意逗号的位置&gt; mtcars[-1:-5,]## 清空这一行的数据&gt; mtcars$mpg = NULL </code></pre><p>如果遇到几个数据表进行汇总,这里要用到数据框的合并,可以使用cbind和rbind函数,cbind添加一列,rbind添加一行.</p><p>cbind合并列</p><pre><code class="r">## USArrests是一个数据集,state.division是一个因子&gt; cbind(USArrests,state.division)</code></pre><p>rbind合并行,这个比较麻烦,需要所有的列有源数据集有相同的列名</p><pre><code class="r">## 取出前20行和尾20行合并&gt; data1 = head(USArrests,20)&gt; data2 = head(USArrests,20)&gt; b = rbind(data1,data2)</code></pre><p>cbind和rbind也可以用于矩阵</p><p>回顾rownames可以取出行名</p><p>判断向量和数据框中哪些是重复值</p><pre><code class="r">&gt; duplicated(who)</code></pre><p>用unique(data4)可以一步取出重复项</p><h2 id="36-数据转换-三"><a href="#36-数据转换-三" class="headerlink" title="36-数据转换(三)"></a>36-数据转换(三)</h2><p>R中行列的调换,excel中可以复制后选择性粘贴.R中可以用<code>t()</code>函数实现转换</p><pre><code class="r">&gt; sractm = t(mtcars)</code></pre><p>单独一行的反转,生物序列中很常见,主要是反向互补,可以使用rev函,reverse的意思 </p><pre><code class="r">&gt; letters [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; &quot;j&quot; &quot;k&quot; &quot;l&quot;[13] &quot;m&quot; &quot;n&quot; &quot;o&quot; &quot;p&quot; &quot;q&quot; &quot;r&quot; &quot;s&quot; &quot;t&quot; &quot;u&quot; &quot;v&quot; &quot;w&quot; &quot;x&quot;[25] &quot;y&quot; &quot;z&quot;&gt; rev(letters) [1] &quot;z&quot; &quot;y&quot; &quot;x&quot; &quot;w&quot; &quot;v&quot; &quot;u&quot; &quot;t&quot; &quot;s&quot; &quot;r&quot; &quot;q&quot; &quot;p&quot; &quot;o&quot;[13] &quot;n&quot; &quot;m&quot; &quot;l&quot; &quot;k&quot; &quot;j&quot; &quot;i&quot; &quot;h&quot; &quot;g&quot; &quot;f&quot; &quot;e&quot; &quot;d&quot; &quot;c&quot;[25] &quot;b&quot; &quot;a&quot;</code></pre><p>数据框中的数据反转,思路就是,提取行名,反转,以反转后的行名为索引</p><pre><code class="r">&gt; rowname(women)&gt; rev(rowname(women))&gt; women[rev(rowname(women))]</code></pre><p>如何修改数据框中的值，可以使用transform()</p><pre><code class="r">## 比如&gt; transform(women,height=height*2.54)</code></pre><p>排序</p><p>sort可以对向量进行排序,可以排序数字,字母,</p><p>sort中也可以设置参数decreasing = T进行从大小排序</p><pre><code class="r">&gt; sort(rivers,decreasing = T)</code></pre><p>order排序返回的是排序后的索引值,在数据框中是比较常用的.返回索引值后可以拿来数据框的排序</p><pre><code class="r">## 如果换成sort就不行了&gt; mtcars[order(mtcars$mpg),]## &quot;-&quot;反向排序,也可以加参数decreasing = T&gt; mtcars[order(-mtcars$mpg),]&gt; mtcars[order(mtcars$mpg,decreasing = T),]</code></pre><p>其次还有rank 函数,</p><h2 id="37-数据转换-四"><a href="#37-数据转换-四" class="headerlink" title="37-数据转换(四)"></a>37-数据转换(四)</h2><p>如何对数据框进行数学计算</p><!--<img src="https://s1.ax1x.com/2020/06/06/t6o5dS.png" alt="t6o5dS.png" border="0" />--><p><img src="https://s1.ax1x.com/2020/06/06/t6o5dS.png" alt="t6o5dS.png"></p><p>统计</p><pre><code class="r">worldphones = as.data.frame(WorldPhones)  ## 转换成数据框rs = rowSums(worldphones)  ## 对行进行求和cm = colMeans(worldphones)  ## 对列求平均total = cbind(worldphones,Total=rs)  ## 添加一列rbind(total,cm)  ## 添加一行</code></pre><p>apply函数,使用与数据框和矩阵,可以有多个功能参数</p><p>主要四两个参数,margin,fun;margin = 1表示对行进行求和,2表示对列进行求和.fun表示功能,要进行的操作</p><pre><code class="r">&gt; ?apply## 对行求和&gt; apply(WorldPhones,MARGIN = 1,FUN = sum)## 对列求平均值&gt; apply(WorldPhones,MARGIN = 2,FUN = mean)</code></pre><p>lapply 表示list apply ,适用于list列表</p><pre><code class="r">&gt; lapply(state.center, length)$x[1] 50$y[1] 50</code></pre><p>sapply</p><pre><code class="r">&gt; sapply(state.center, length) x  y 50 50 </code></pre><p>tapply 用于处理因子数据,根据因子分组,然后根据因子分组进行处理</p><p>第一个参数问数据集,第三个参数是要使用的函数</p><p>没咋懂!!!</p><pre><code class="r">&gt; tapply(state.name,state.division,FUN=length)       New England    Middle Atlantic                  6                  3     South Atlantic East South Central                  8                  4 West South Central East North Central                  4                  5 West North Central           Mountain                  7                  8            Pacific                  5 </code></pre><h3 id="R中数据的中心化与标准化处理"><a href="#R中数据的中心化与标准化处理" class="headerlink" title="R中数据的中心化与标准化处理"></a>R中数据的中心化与标准化处理</h3><p>数据的中心化,是指数据集中的各项数据减去数据集的均值</p><p>数据的标准化,是指在中心化后在除以数据集的标准差,即数据集中的各项数据减去数据集的均值再除以数据集的标准差.</p><p>R中实现中心化和标准化可以用scale函数,有两个参数,center和scale</p><p>比如state.x77这个数据集</p><pre><code class="r">&gt; x = scale(state.x77,center = T,scale = T)&gt; heatmap(x)</code></pre><h2 id="38-数据格式的转换-reshape2包"><a href="#38-数据格式的转换-reshape2包" class="headerlink" title="38-数据格式的转换(reshape2包)"></a>38-数据格式的转换(reshape2包)</h2><p>大概的过程相当于钢铁的制造过程,先把铁融化,然后在做成想要的形状.在数据的过程中,称为柔数据,很像是excel中的数据透视表.</p><pre><code class="r">## 这里是一组空气质量的数据&gt; names(airquality) = tolower(names(airquality))  ## 把首字母小写&gt; melt(airquality)  ## 融合数据&gt; aql = melt(airquality)  ## 融合后数据变为三列&gt; aql = melt(airquality,id.vars = c(&quot;month&quot;,&quot;day&quot;))  ## 将月份和日期作为id变量.&gt; aqw = dcast(aql,month+day ~variable)  ## 重铸数据,与variable相关联&gt; aqw = dcast(aql,month+day ~variable,fun.aggregate = mean,na.rm=TRUE)</code></pre><p>没怎么听懂.  可以在右下的框框中找到reshape2的帮助包,找到acast和dcast把其中的案例都运行一边,</p><p>~ 表示有关联有关系 </p><h2 id="39-数据格式的转换-tidyr包"><a href="#39-数据格式的转换-tidyr包" class="headerlink" title="39-数据格式的转换(tidyr包)"></a>39-数据格式的转换(tidyr包)</h2><p>简洁数据中</p><ol><li>每一列代表一个变量</li><li>每一行代表一个观测</li><li>每一个观测的值在表中的一个单元格中 </li></ol><p>tidyr包中有四个重要的函数</p><ul><li>gather 主要是将宽数据转换成长数据,类似于reshape2包中的melt函数   </li><li>spread 将长数据转换成宽数据,类似于reshape中的cast函数</li><li>unite 是将多列合并为一列</li><li>separate 是将一列分成多列</li></ul><p>mtcars数据集为例,就是一个标准的tidydata数据集</p><pre><code class="r">&gt; tdata = mtcars[1:10,1:3]&gt; tdata                   mpg cyl  dispMazda RX4         21.0   6 160.0Mazda RX4 Wag     21.0   6 160.0Datsun 710        22.8   4 108.0Hornet 4 Drive    21.4   6 258.0Hornet Sportabout 18.7   8 360.0Valiant           18.1   6 225.0Duster 360        14.3   8 360.0Merc 240D         24.4   4 146.7Merc 230          22.8   4 140.8Merc 280          19.2   6 167.6## 以第一列的数据添加到数据集中&gt; tdata = data.frame(names=rownames(tdata),tdata)&gt; tdata                              names  mpg cyl  dispMazda RX4                 Mazda RX4 21.0   6 160.0Mazda RX4 Wag         Mazda RX4 Wag 21.0   6 160.0Datsun 710               Datsun 710 22.8   4 108.0Hornet 4 Drive       Hornet 4 Drive 21.4   6 258.0Hornet Sportabout Hornet Sportabout 18.7   8 360.0Valiant                     Valiant 18.1   6 225.0Duster 360               Duster 360 14.3   8 360.0Merc 240D                 Merc 240D 24.4   4 146.7Merc 230                   Merc 230 22.8   4 140.8Merc 280                   Merc 280 19.2   6 167.6</code></pre><p>gather函数,可以调整行列</p><pre><code class="r">## 对dyl,disp,mpg进行处理,如下&gt; gather(tdata,key = &quot;Key&quot;,value = &quot;Value&quot;,cyl,disp,mpg)               names  Key Value1          Mazda RX4  cyl   6.02      Mazda RX4 Wag  cyl   6.03         Datsun 710  cyl   4.04     Hornet 4 Drive  cyl   6.05  Hornet Sportabout  cyl   8.06            Valiant  cyl   6.07         Duster 360  cyl   8.08          Merc 240D  cyl   4.09           Merc 230  cyl   4.010          Merc 280  cyl   6.011         Mazda RX4 disp 160.012     Mazda RX4 Wag disp 160.013        Datsun 710 disp 108.014    Hornet 4 Drive disp 258.015 Hornet Sportabout disp 360.016           Valiant disp 225.017        Duster 360 disp 360.018         Merc 240D disp 146.719          Merc 230 disp 140.820          Merc 280 disp 167.621         Mazda RX4  mpg  21.022     Mazda RX4 Wag  mpg  21.023        Datsun 710  mpg  22.824    Hornet 4 Drive  mpg  21.425 Hornet Sportabout  mpg  18.726           Valiant  mpg  18.127        Duster 360  mpg  14.328         Merc 240D  mpg  24.429          Merc 230  mpg  22.830          Merc 280  mpg  19.2## 可用&quot;-&quot;号,将disp单独放入一列中,&gt; gdata = gather(tdata,key = &quot;Key&quot;,value = &quot;Value&quot;,cyl,-disp,mpg)&gt; gdata               names  disp Key Value1          Mazda RX4 160.0 cyl   6.02      Mazda RX4 Wag 160.0 cyl   6.03         Datsun 710 108.0 cyl   4.04     Hornet 4 Drive 258.0 cyl   6.05  Hornet Sportabout 360.0 cyl   8.06            Valiant 225.0 cyl   6.07         Duster 360 360.0 cyl   8.08          Merc 240D 146.7 cyl   4.09           Merc 230 140.8 cyl   4.010          Merc 280 167.6 cyl   6.011         Mazda RX4 160.0 mpg  21.012     Mazda RX4 Wag 160.0 mpg  21.013        Datsun 710 108.0 mpg  22.814    Hornet 4 Drive 258.0 mpg  21.415 Hornet Sportabout 360.0 mpg  18.716           Valiant 225.0 mpg  18.117        Duster 360 360.0 mpg  14.318         Merc 240D 146.7 mpg  24.419          Merc 230 140.8 mpg  22.820          Merc 280 167.6 mpg  19.2## 也可以用列号gather(tdata,key = &quot;Key&quot;,value = &quot;Value&quot;,2:4)</code></pre><p>spread 函数,基本和gather相反</p><pre><code class="r">&gt; spdata = spread(gdata,key = &quot;Key&quot;,value = &quot;Value&quot;)&gt; spdata               names cyl  disp  mpg1         Datsun 710   4 108.0 22.82         Duster 360   8 360.0 14.33     Hornet 4 Drive   6 258.0 21.44  Hornet Sportabout   8 360.0 18.75          Mazda RX4   6 160.0 21.06      Mazda RX4 Wag   6 160.0 21.07           Merc 230   4 140.8 22.88          Merc 240D   4 146.7 24.49           Merc 280   6 167.6 19.210           Valiant   6 225.0 18.1</code></pre><p>spread默认识别”.”分割符,sep可以指定分隔符如:</p><pre><code class="r">&gt; df = data.frame(x = c(NA,&quot;a.b&quot;,&quot;a.c&quot;,&quot;b.c&quot;)&gt; df     x1 &lt;NA&gt;2  a.b3  a.c4  b.c&gt; separate(df,col = x,into = c(&quot;A&quot;,&quot;B&quot;),sep = &quot;-&quot;)     A    B1 &lt;NA&gt; &lt;NA&gt;2    a    b3    a    c4    b    c</code></pre><p>unite是一个相反的操作</p><pre><code class="r">&gt; unite(x,col = &quot;CD&quot;,A,B,sep = &quot;-&quot;)     CD1 NA-NA2   a-b3   a-c4   b-c</code></pre><h2 id="40-数据格式的转换-dplyr包"><a href="#40-数据格式的转换-dplyr包" class="headerlink" title="40-数据格式的转换(dplyr包)"></a>40-数据格式的转换(dplyr包)</h2><p>这是一个非常强大的包</p><pre><code class="r">&gt; ls(&quot;package:dplyr&quot;)  ## 可以列出包的所有的函数</code></pre><p>dplyr::filer功能,根据给定条件,对数据进行过滤,例如</p><pre><code class="r">## dplyr::是调用的这个包中的函数,因为函数太多所以可以防止出现奇异&gt; dplyr::filter(iris,Sepal.Length&gt;7)  ## 过滤出花萼长度大于7的   Sepal.Length Sepal.Width Petal.Length Petal.Width   Species1           7.1         3.0          5.9         2.1 virginica2           7.6         3.0          6.6         2.1 virginica3           7.3         2.9          6.3         1.8 virginica4           7.2         3.6          6.1         2.5 virginica5           7.7         3.8          6.7         2.2 virginica6           7.7         2.6          6.9         2.3 virginica7           7.7         2.8          6.7         2.0 virginica8           7.2         3.2          6.0         1.8 virginica9           7.2         3.0          5.8         1.6 virginica10          7.4         2.8          6.1         1.9 virginica11          7.9         3.8          6.4         2.0 virginica12          7.7         3.0          6.1         2.3 virginica</code></pre><p>dplyr::distinct用于去除重复行,相当于unic</p><pre><code class="r">&gt; dplyr::distinct(rbind(iris[1:10,],iris[1:15,]))   Sepal.Length Sepal.Width Petal.Length Petal.Width Species1           5.1         3.5          1.4         0.2  setosa2           4.9         3.0          1.4         0.2  setosa3           4.7         3.2          1.3         0.2  setosa4           4.6         3.1          1.5         0.2  setosa5           5.0         3.6          1.4         0.2  setosa6           5.4         3.9          1.7         0.4  setosa7           4.6         3.4          1.4         0.3  setosa8           5.0         3.4          1.5         0.2  setosa9           4.4         2.9          1.4         0.2  setosa10          4.9         3.1          1.5         0.1  setosa11          5.4         3.7          1.5         0.2  setosa12          4.8         3.4          1.6         0.2  setosa13          4.8         3.0          1.4         0.1  setosa14          4.3         3.0          1.1         0.1  setosa15          5.8         4.0          1.2         0.2  setosa</code></pre><p>dplyr::slice()用于切片</p><pre><code class="r">&gt; dplyr::slice(iris,10:15)  Sepal.Length Sepal.Width Petal.Length Petal.Width Species1          4.9         3.1          1.5         0.1  setosa2          5.4         3.7          1.5         0.2  setosa3          4.8         3.4          1.6         0.2  setosa4          4.8         3.0          1.4         0.1  setosa5          4.3         3.0          1.1         0.1  setosa6          5.8         4.0          1.2         0.2  setosa</code></pre><ul><li><code>dplyr::filter(iris,Sepal.Length&gt;7)</code> 过滤出花萼长度大于7的花</li><li><code>dplyr::slice(iris,10:15)</code> 表示切出10:15的行</li><li><code>dplyr::sample_n(iris,10)</code> 表示随机抽取10行</li><li><code>dplyr::sample_frac(iris,0.1)</code> 按比例抽取10分之一的数据</li><li><code>dplyr::arrange(iris,Sepal.Length)</code> 表示安装花萼长度进行排序</li><li><code>dplyr::arrange(iris,desc(Sepal.Length))</code> 表示反向进行排序</li></ul><h4 id="dplyr中取子集的功能"><a href="#dplyr中取子集的功能" class="headerlink" title="dplyr中取子集的功能"></a>dplyr中取子集的功能</h4><p>介绍中<code>?select</code>中有大量的示例</p><h4 id="dplyr的统计函数"><a href="#dplyr的统计函数" class="headerlink" title="dplyr的统计函数"></a>dplyr的统计函数</h4><p>可以使用summarise进行统计</p><ul><li><code>summarise(iris,avg=mean(Sepal.Length))</code> 可以计算花萼的平均长度</li><li><code>summarise(iris,sum=sum(Sepal.Length))</code> 可以计算花萼的总长度</li></ul><h3 id="链式操作符-gt"><a href="#链式操作符-gt" class="headerlink" title="链式操作符%&gt;%"></a>链式操作符%&gt;%</h3><p>将一个函数的输出传递给下一个函数,用作下一个函数的输入,类似于linux中的管道,Rstudio中可以使用ctrl+shift+M调用</p><pre><code class="r">iris 通过管道进行分组,再通过管道计算平均值,再通过管道进行排序&gt; iris %&gt;% group_by(Species) %&gt;% summarise(avg=mean(Sepal.Width)) %&gt;% arrange(avg)`summarise()` ungrouping output (override with `.groups` argument)# A tibble: 3 x 2  Species      avg  &lt;fct&gt;      &lt;dbl&gt;1 versicolor  2.772 virginica   2.973 setosa      3.43</code></pre><p>mutate可以添加新的变量</p><h3 id="dplyr中双表格的操控"><a href="#dplyr中双表格的操控" class="headerlink" title="dplyr中双表格的操控"></a>dplyr中双表格的操控</h3><p>整合方式包括左连接,有链接,内连接,全连接,半连接,反链接等.内连接是取交集,全连接是取并集.</p><pre><code class="r">## 建立两个数据框&gt; a = data.frame(x1=c(&quot;A&quot;,&quot;B&quot;,&quot;C&quot;),x2=c(1,2,3))&gt; b = data.frame(x1=c(&quot;A&quot;,&quot;B&quot;,&quot;D&quot;),x3=c(T,F,T))## 左连接,就是以左边的表为基础进行合并&gt;  dplyr::left_join(a,b,by=&quot;x1&quot;)  x1 x2    x31  A  1  TRUE2  B  2 FALSE3  C  3    NA## 右连接,就是以右边的表为基础进行合并&gt;  dplyr::right_join(a,b,by=&quot;x1&quot;)  x1 x2    x31  A  1  TRUE2  B  2 FALSE3  D NA  TRUE## 全连接取并集&gt; dplyr::full_join(a,b,by=&quot;x1&quot;)  x1 x2    x31  A  1  TRUE2  B  2 FALSE3  C  3    NA4  D NA  TRUE## 半链接根据右侧表的内容于对左侧表进行过滤,不要交集,对a表进行操作.&gt; dplyr::semi_join(a,b,by=&quot;x1&quot;)  x1 x21  A  12  B  2## 反链接也是根据右侧表进行操作,是将左侧表的补集取出来.对a表进行操作.&gt; dplyr::anti_join(a,b,by=&quot;x1&quot;)  x1 x21  C  3</code></pre><h2 id="41-R函数"><a href="#41-R函数" class="headerlink" title="41-R函数"></a>41-R函数</h2><p>类似于linux中是命令</p><!--<img src="https://s1.ax1x.com/2020/06/09/t5F6gO.png" alt="t5F6gO.png" border="0" />--><p><img src="https://s1.ax1x.com/2020/06/09/t5F6gO.png" alt="t5F6gO.png"></p><p>lm 是一个回归分析<br>老师强调的是多用.</p><h2 id="42-选项参数"><a href="#42-选项参数" class="headerlink" title="42-选项参数"></a>42-选项参数</h2><p>程序,选项,参数</p><p>选项参数:</p><ol><li>输入控制部分</li><li>输出控制部分</li><li>调节部分</li></ol><p>在linux中数据几个参数就被称作几元函数,R中也是一样的<br><a href="https://www.bilibili.com/video/BV19x411X7C6?p=42">视频</a><br>还是要不停的操作</p><h2 id="43-数学统计函数"><a href="#43-数学统计函数" class="headerlink" title="43-数学统计函数"></a>43-数学统计函数</h2><p>概率论是统计学的基础,R有许多处理概率的函数.可能涉及到,样本空间,对立与互斥,随机事件与必然事件,概率密度,概率分布等.这个要你有统计学相关的书籍 </p><ul><li>d 概率密度函数</li><li>p 分布函数</li><li>q 分布函数的反函数</li><li>r 产生相同分布的随机函数</li></ul><h4 id="正太分布相关的函数"><a href="#正太分布相关的函数" class="headerlink" title="正太分布相关的函数"></a>正太分布相关的函数</h4><pre><code class="r">## 分别为正太概率密度函数,正太分布函数,正太分位数函数,正太分布的随机数函数?Normaldnorm(x, mean = 0, sd = 1, log = FALSE)pnorm(q, mean = 0, sd = 1, lower.tail = TRUE, log.p = FALSE)qnorm(p, mean = 0, sd = 1, lower.tail = TRUE, log.p = FALSE)rnorm(n, mean = 0, sd = 1)</code></pre><p>比如随机生成100个随机的正太分布的数字</p><pre><code class="r">&gt; rnorm(n = 100,mean = 15,sd = 2)  [1] 18.82627 14.48052 15.64733 17.10765 16.69834  [6] 17.18229 15.82709 14.38638 17.03382 15.75992 [11] 15.62620 15.91558 16.44487 12.72194 15.26981 [16] 15.41339 17.40237 16.06431 14.18183 13.73592 [21] 14.57075 14.18284 15.91646 15.79732 12.86899 [26] 10.33624 11.68006 17.04716 11.75353 14.56665 [31] 19.45208 10.68233 13.43531 13.47316 14.27902 [36] 19.29866 12.14214 15.09897 12.73730 14.76324 [41] 13.53597 19.82190 18.34059 14.48723 16.30598 [46] 12.61513 15.49195 14.33117 15.56077 15.10224 [51] 18.87988 10.82265 17.50272 16.03550 13.69167 [56] 15.53061 14.92809 13.31095 16.12193 13.37350 [61] 14.97857 17.93824 15.81937 15.14789 15.02264 [66] 15.35681 15.06818 16.20024 15.49239 13.87530 [71] 15.07941 11.02497 15.94322 15.67173 12.82916 [76] 14.49088 15.23593 14.89429 15.39066 17.03379 [81] 15.07567 13.72972 15.06769 16.03017 18.25667 [86] 11.01588 12.57675 17.13522 16.01980 10.52023 [91] 19.66291 13.17814 17.31925 14.03456 16.18037 [96] 15.59317 12.31323 16.43977 16.09725 14.29555 &gt; round(rnorm(n = 100,mean = 15,sd = 2))  ## 可用于取整数,每次运行都是不同正太分布的数字</code></pre><h4 id="与离散分布相关的函数"><a href="#与离散分布相关的函数" class="headerlink" title="与离散分布相关的函数"></a>与离散分布相关的函数</h4><!--<img src="https://s1.ax1x.com/2020/06/09/t5u0VU.png" alt="t5u0VU.png" border="0" />--><p><img src="https://s1.ax1x.com/2020/06/09/t5u0VU.png" alt="t5u0VU.png"></p><p>比如几种分布</p><pre><code class="r">## 集合分布&gt; ?Geometric## 超几何分布&gt; ?Hypergeometric</code></pre><p>这些函数的作用,,,</p><ul><li>可以生成这种函数的随机数,并绘制出对应的分布曲线来查看,比如<pre><code class="r">&gt; x = rnorm(n=100,mean = 15,sd = 2)&gt; qqnorm(x)</code></pre></li></ul><h4 id="随机数的生成"><a href="#随机数的生成" class="headerlink" title="随机数的生成"></a>随机数的生成</h4><pre><code class="r">&gt; runif(10)*10## 生成50个最小为1最大为100的随机数&gt; runif(50,min=1,max=100)</code></pre><p>随机种子,要求复现,这时就要用到set.seed()如:</p><pre><code class="r">## 每次这样运行都可以得到同样的随机数&gt; set.seed(666)&gt; runif(10) [1] 0.77436849 0.19722419 0.97801384 0.20132735 [5] 0.36124443 0.74261194 0.97872844 0.49811371 [9] 0.01331584 0.25994613</code></pre><h2 id="44-描述性统计函数"><a href="#44-描述性统计函数" class="headerlink" title="44-描述性统计函数"></a>44-描述性统计函数</h2><h3 id="summary函数"><a href="#summary函数" class="headerlink" title="summary函数"></a>summary函数</h3><p>回归分析中大量的用到这个函数</p><pre><code class="r">## 提供了最小,四分位数,中位数,平均值,,最小值,,&gt; myvare = mtcars[c(&quot;mpg&quot;,&quot;hp&quot;,&quot;wt&quot;,&quot;am&quot;)]&gt; summary(myvare)      mpg              hp              wt              am         Min.   :10.40   Min.   : 52.0   Min.   :1.513   Min.   :0.0000   1st Qu.:15.43   1st Qu.: 96.5   1st Qu.:2.581   1st Qu.:0.0000   Median :19.20   Median :123.0   Median :3.325   Median :0.0000   Mean   :20.09   Mean   :146.7   Mean   :3.217   Mean   :0.4062   3rd Qu.:22.80   3rd Qu.:180.0   3rd Qu.:3.610   3rd Qu.:1.0000   Max.   :33.90   Max.   :335.0   Max.   :5.424   Max.   :1.0000</code></pre><h3 id="fivenum"><a href="#fivenum" class="headerlink" title="fivenum()"></a>fivenum()</h3><p>与summary类似可以返回五个数,最小值,四分位数,中位数</p><pre><code class="r">&gt; fivenum(myvare$hp)[1]  52  96 123 180 335</code></pre><h3 id="pastecs包"><a href="#pastecs包" class="headerlink" title="pastecs包"></a>pastecs包</h3><p>这个可以计算种类繁多的统计量</p><pre><code class="r">## 默认的 basic=T 计算基础统计值&gt; stat.desc(myvare)                     mpg           hp          wt          amnbr.val       32.0000000   32.0000000  32.0000000 32.00000000nbr.null       0.0000000    0.0000000   0.0000000 19.00000000nbr.na         0.0000000    0.0000000   0.0000000  0.00000000min           10.4000000   52.0000000   1.5130000  0.00000000max           33.9000000  335.0000000   5.4240000  1.00000000range         23.5000000  283.0000000   3.9110000  1.00000000sum          642.9000000 4694.0000000 102.9520000 13.00000000median        19.2000000  123.0000000   3.3250000  0.00000000mean          20.0906250  146.6875000   3.2172500  0.40625000SE.mean        1.0654240   12.1203173   0.1729685  0.08820997CI.mean.0.95   2.1729465   24.7195501   0.3527715  0.17990541var           36.3241028 4700.8669355   0.9573790  0.24899194std.dev        6.0269481   68.5628685   0.9784574  0.49899092coef.var       0.2999881    0.4674077   0.3041285  1.22828533## 计算描述性统计&gt; stat.desc(myvare,basic = T)                     mpg           hp          wt          amnbr.val       32.0000000   32.0000000  32.0000000 32.00000000nbr.null       0.0000000    0.0000000   0.0000000 19.00000000nbr.na         0.0000000    0.0000000   0.0000000  0.00000000min           10.4000000   52.0000000   1.5130000  0.00000000max           33.9000000  335.0000000   5.4240000  1.00000000range         23.5000000  283.0000000   3.9110000  1.00000000sum          642.9000000 4694.0000000 102.9520000 13.00000000median        19.2000000  123.0000000   3.3250000  0.00000000mean          20.0906250  146.6875000   3.2172500  0.40625000SE.mean        1.0654240   12.1203173   0.1729685  0.08820997CI.mean.0.95   2.1729465   24.7195501   0.3527715  0.17990541var           36.3241028 4700.8669355   0.9573790  0.24899194std.dev        6.0269481   68.5628685   0.9784574  0.49899092coef.var       0.2999881    0.4674077   0.3041285  1.22828533## norm 就会计算一些统计值,如正太分布统计量,偏度,峰度等&gt; stat.desc(myvare,norm = T)                     mpg            hp           wt            amnbr.val       32.0000000   32.00000000  32.00000000  3.200000e+01nbr.null       0.0000000    0.00000000   0.00000000  1.900000e+01nbr.na         0.0000000    0.00000000   0.00000000  0.000000e+00min           10.4000000   52.00000000   1.51300000  0.000000e+00max           33.9000000  335.00000000   5.42400000  1.000000e+00range         23.5000000  283.00000000   3.91100000  1.000000e+00sum          642.9000000 4694.00000000 102.95200000  1.300000e+01median        19.2000000  123.00000000   3.32500000  0.000000e+00mean          20.0906250  146.68750000   3.21725000  4.062500e-01SE.mean        1.0654240   12.12031731   0.17296847  8.820997e-02CI.mean.0.95   2.1729465   24.71955013   0.35277153  1.799054e-01var           36.3241028 4700.86693548   0.95737897  2.489919e-01std.dev        6.0269481   68.56286849   0.97845744  4.989909e-01coef.var       0.2999881    0.46740771   0.30412851  1.228285e+00skewness       0.6106550    0.72602366   0.42314646  3.640159e-01skew.2SE       0.7366922    0.87587259   0.51048252  4.391476e-01kurtosis      -0.3727660   -0.13555112  -0.02271075 -1.924741e+00kurt.2SE      -0.2302812   -0.08373853  -0.01402987 -1.189035e+00normtest.W     0.9475647    0.93341934   0.94325772  6.250744e-01normtest.p     0.1228814    0.04880824   0.09265499  7.836354e-08</code></pre><h3 id="doBy包"><a href="#doBy包" class="headerlink" title="doBy包"></a>doBy包</h3><p>可以一次返回多个计算统计量</p><pre><code class="r">## 右边的变量是分组型的分组变量,data接一个数据框,fun接一个函数,可以是自定义函数&gt; summaryBy(mpg+hp+wt ~ am,data = myvare,FUN = mean)  am mpg.mean  hp.mean  wt.mean1  0 17.14737 160.2632 3.7688952  1 24.39231 126.8462 2.411000</code></pre><h2 id="45-频数统计函数"><a href="#45-频数统计函数" class="headerlink" title="45-频数统计函数"></a>45-频数统计函数</h2><p>如果一个数据是因子,因子是直接可以进行分组的</p><pre><code class="r">&gt; mt_cyl = as.factor(mtcars$cyl)&gt; mt_cyl [1] 6 6 4 6 8 6 8 4 4 6 6 8 8 8 8 8 8 4 4 4 4 8 8 8 8[26] 4 4 4 8 6 8 4Levels: 4 6 8&gt; split(mtcars,mt_cyl)## 这样就可以根据气缸的个数对汽车进行分组</code></pre><p>如果不是一个明显的因子,可以用cut进行分割</p><pre><code class="r">## 10到50,以10为步长进行分组&gt;  cut(mtcars$mpg,c(seq(10,50,10))) [1] (20,30] (20,30] (20,30] (20,30] (10,20] (10,20] [7] (10,20] (20,30] (20,30] (10,20] (10,20] (10,20][13] (10,20] (10,20] (10,20] (10,20] (10,20] (30,40][19] (30,40] (30,40] (20,30] (10,20] (10,20] (10,20][25] (10,20] (20,30] (20,30] (30,40] (10,20] (10,20][31] (10,20] (20,30]Levels: (10,20] (20,30] (30,40] (40,50]## 然后直接使用table进行统计&gt; table(cut(mtcars$mpg,c(seq(10,50,10))))(10,20] (20,30] (30,40] (40,50]      18      10       4       0 </code></pre><h4 id="prop-table计算频率函数"><a href="#prop-table计算频率函数" class="headerlink" title="prop.table计算频率函数"></a>prop.table计算频率函数</h4><pre><code class="r">&gt; prop.table(table(mtcars$cyl))      4       6       8 0.34375 0.21875 0.43750 </code></pre><h4 id="vcd"><a href="#vcd" class="headerlink" title="vcd"></a>vcd</h4><p>如果是二维的数据框呢</p><ul><li><p>如果是用table的话</p><pre><code class="r">## 安慰剂和治疗组的区分,这个在实验的时候很常用&gt; table(Arthritis$Treatment,Arthritis$Improved)        None Some MarkedPlacebo   29    7      7Treated   13    7     21</code></pre></li></ul><h4 id="xtabs"><a href="#xtabs" class="headerlink" title="xtabs"></a>xtabs</h4><p>这个函数是可以自定义公式</p><pre><code class="r">&gt; xtabs(~ Treatment + Improved,data = Arthritis)         ImprovedTreatment None Some Marked  Placebo   29    7      7  Treated   13    7     21</code></pre><p>二维列联表可以用margin.table</p><pre><code class="r">## 这里的1代表的是行&gt; x = xtabs(~ Treatment + Improved,data = Arthritis)&gt; margin.table(x)[1] 84&gt; margin.table(x,1)TreatmentPlacebo Treated      43      41## 频率占比统计&gt; prop.table(x,1)         ImprovedTreatment      None      Some    Marked  Placebo 0.6744186 0.1627907 0.1627907  Treated 0.3170732 0.1707317 0.5121951</code></pre><p>addmargins()可以直接将算出的和添加到表中,也可以设置1和2,只添加行或列.</p><pre><code class="r">&gt; addmargins(x)         ImprovedTreatment None Some Marked Sum  Placebo   29    7      7  43  Treated   13    7     21  41  Sum       42   14     28  84</code></pre><h3 id="三维列联表的计算"><a href="#三维列联表的计算" class="headerlink" title="三维列联表的计算"></a>三维列联表的计算</h3><pre><code class="r">&gt; x = xtabs(~ Treatment + Improved + Sex,data = Arthritis)&gt; x, , Sex = Female         ImprovedTreatment None Some Marked  Placebo   19    7      6  Treated    6    5     16, , Sex = Male         ImprovedTreatment None Some Marked  Placebo   10    0      1  Treated    7    2      5## 这样的表可能不是很好看,ftable()可以将表转换成评估式的列联表&gt; ftable(x)                   Sex Female MaleTreatment Improved                Placebo   None             19   10          Some              7    0          Marked            6    1Treated   None              6    7          Some              5    2          Marked           16    5</code></pre><h2 id="46-R中的独立性检验函数"><a href="#46-R中的独立性检验函数" class="headerlink" title="46-R中的独立性检验函数"></a>46-R中的独立性检验函数</h2><p>独立检验是根据频数信息判断两类因子彼此相关或相互独立的假设检.所谓独立就是看看变量之间是否是独立的.</p><p>主要有三个检验方法</p><ol><li>卡方检验</li><li>Fisher检验</li><li>Cochran-Mantel-Haenszel检验</li></ol><h3 id="假设检验"><a href="#假设检验" class="headerlink" title="假设检验"></a>假设检验</h3><p>假设检验是梳理统计学中根据一定假设条件由样本推断总体的一种方法.</p><p>原假设–没有发生;</p><p>备择假设–发生了;</p><p>具体作法是:根据问题的需要对所研究的总体作某种假设,记作HO ;选取合适的统计量,这个统计量的选取要使得在假设H0成立时,其分布为已知;由实测的样本,计算出统计量的值,并根据预先给定的显著性水平进行检验,作出拒绝或接受假设HO的判断。</p><h3 id="p-value-probability的值"><a href="#p-value-probability的值" class="headerlink" title="p-value probability的值"></a>p-value probability的值</h3><p>是一个通过计算得到的概率值,也就是原假设为真时,得到最大的或者超出所得到的检验统计量的概率.</p><p>一般将p值定位到0.05,当p &lt; 0.05拒绝原假设,p &gt; 0.05,不拒绝原假设.</p><p>简单的理解就是p值越小原假设越不靠谱,拒绝它,p值越大,说明原假设越靠谱,不拒绝它</p><p>p值越小相关性越大</p><p>以上次药物的有效性为例,进行卡方检验</p><pre><code class="r">&gt; mytable = table(Arthritis$Treatment,Arthritis$Improved)&gt; chisq.test(mytable)    Pearson&#39;s Chi-squared testdata:  mytableX-squared = 13.055, df = 2, p-value = 0.001463## p值为0.001463说明两个变量之间是有关系的,说明药物是有效果的&gt; mytable2 = table(Arthritis$Sex,Arthritis$Improved)&gt; chisq.test(mytable2)    Pearson&#39;s Chi-squared testdata:  mytable2X-squared = 4.8407, df = 2, p-value = 0.08889## 这里检测的是性别与改善之间的关系</code></pre><h3 id="fisher-精确检验"><a href="#fisher-精确检验" class="headerlink" title="fisher 精确检验"></a>fisher 精确检验</h3><p>也是独立性检验,原理是行和列是独立</p><pre><code class="r">&gt; fisher.test(mytable)    Fisher&#39;s Exact Test for Count Datadata:  mytablep-value = 0.001393alternative hypothesis: two.sided## 与卡方检验是一致的,计算的也是P值</code></pre><h3 id="mantelhaen-test-检测"><a href="#mantelhaen-test-检测" class="headerlink" title="mantelhaen.test 检测"></a>mantelhaen.test 检测</h3><p>两个名义变量在第三个变量每一层中都是条件独立的,需要三个变量</p><pre><code class="r">&gt; mytable3 = xtabs(~Treatment + Improved + Sex,data = Arthritis)&gt; mytable3, , Sex = Female         ImprovedTreatment None Some Marked  Placebo   19    7      6  Treated    6    5     16, , Sex = Male         ImprovedTreatment None Some Marked  Placebo   10    0      1  Treated    7    2      5&gt; mantelhaen.test(mytable3)    Cochran-Mantel-Haenszel testdata:  mytable3Cochran-Mantel-Haenszel M^2 = 14.632, df = 2, p-value = 0.0006647## 这里的p值很小,因为列联表的结果是以性别来区分的,这里表示药物的治疗在性别的每一个水平上不独立.</code></pre><p>这里的独立性检验的顺序是很总要的</p><pre><code class="r">## 这里变量的顺序是很重要的&gt; mytable3 = xtabs(~Treatment + Sex + Improved ,data = Arthritis)&gt; mantelhaen.test(mytable3)    Mantel-Haenszel chi-squared test with continuity correctiondata:  mytable3Mantel-Haenszel X-squared = 2.0863, df = 1, p-value = 0.1486alternative hypothesis: true common odds ratio is not equal to 195 percent confidence interval: 0.8566711 8.0070521sample estimates:common odds ratio          2.619048 </code></pre><p>也由很多的包可以进行独立性检验</p><h2 id="47-相关性分析函数"><a href="#47-相关性分析函数" class="headerlink" title="47-相关性分析函数"></a>47-相关性分析函数</h2><p>相关性分析是指对两个或多个具备相关性的变量元素进行分析,从而衡量两个变量因素的相关密切程度。相关性的元素之间需要存在一定的联系或者概率才可以进行相关性分析。</p><p>简单来说就是变量之间是否有关系。</p><p>两个变量如果不独立就可以进行相关性检验,可能是正相关用”+”表示,也可能是负相关”-“,</p><p>相关性衡量指标,指标表示是都是同一个东西,只是表示的方法指标不同而已</p><ul><li>Pearson相关系数</li><li>Spearman相关系数</li><li>Kendall相关系数</li><li>偏相关系数</li><li>多分格相关系数</li><li>多系列相关系数</li></ul><p>计算相关性系数都是使用同一个函数cor(),可以计算三种相关系数,pearson,kendall,spearman,默认是pearson</p><h4 id="cor函数"><a href="#cor函数" class="headerlink" title="cor函数"></a>cor函数</h4><pre><code class="r">## 这里计算一下谋杀率和什么有关&gt; ?cor&gt; state.x77&gt; cor(state.x77)            Population     Income  Illiteracy    Life Exp     Murder     HS Grad      Frost        AreaPopulation  1.00000000  0.2082276  0.10762237 -0.06805195  0.3436428 -0.09848975 -0.3321525  0.02254384Income      0.20822756  1.0000000 -0.43707519  0.34025534 -0.2300776  0.61993232  0.2262822  0.36331544Illiteracy  0.10762237 -0.4370752  1.00000000 -0.58847793  0.7029752 -0.65718861 -0.6719470  0.07726113Life Exp   -0.06805195  0.3402553 -0.58847793  1.00000000 -0.7808458  0.58221620  0.2620680 -0.10733194Murder      0.34364275 -0.2300776  0.70297520 -0.78084575  1.0000000 -0.48797102 -0.5388834  0.22839021HS Grad    -0.09848975  0.6199323 -0.65718861  0.58221620 -0.4879710  1.00000000  0.3667797  0.33354187Frost      -0.33215245  0.2262822 -0.67194697  0.26206801 -0.5388834  0.36677970  1.0000000  0.05922910Area        0.02254384  0.3633154  0.07726113 -0.10733194  0.2283902  0.33354187  0.0592291  1.00000000</code></pre><p>这是一个对角矩阵对角线是自己与自己的相关性,都是1,最大相关系数.正的就是正相关,负的就是不相关,或反着来.</p><h4 id="cov函数"><a href="#cov函数" class="headerlink" title="cov函数"></a>cov函数</h4><p>可以用来计算协方差,基本与cor是一致的</p><pre><code class="r">&gt; cov(state.x77)              Population        Income   Illiteracy      Life Exp       Murder       HS Grad        Frost          AreaPopulation 19931683.7588   571229.7796  292.8679592 -4.078425e+02  5663.523714  -3551.509551 -77081.97265  8.587917e+06Income       571229.7796   377573.3061 -163.7020408  2.806632e+02  -521.894286   3076.768980   7227.60408  1.904901e+07Illiteracy      292.8680     -163.7020    0.3715306 -4.815122e-01     1.581776     -3.235469    -21.29000  4.018337e+03Life Exp       -407.8425      280.6632   -0.4815122  1.802020e+00    -3.869480      6.312685     18.28678 -1.229410e+04Murder         5663.5237     -521.8943    1.5817755 -3.869480e+00    13.627465    -14.549616   -103.40600  7.194043e+04HS Grad       -3551.5096     3076.7690   -3.2354694  6.312685e+00   -14.549616     65.237894    153.99216  2.298732e+05Frost        -77081.9727     7227.6041  -21.2900000  1.828678e+01  -103.406000    153.992163   2702.00857  2.627039e+05Area        8587916.9494 19049013.7510 4018.3371429 -1.229410e+04 71940.429959 229873.192816 262703.89306  7.280748e+09</code></pre><p>如果要精准的显示谋杀率和哪些指数有关</p><pre><code class="r">&gt; colnames(state.x77)[1] &quot;Population&quot; &quot;Income&quot;     &quot;Illiteracy&quot; &quot;Life Exp&quot;  [5] &quot;Murder&quot;     &quot;HS Grad&quot;    &quot;Frost&quot;      &quot;Area&quot;      &gt; x = state.x77[,c(1,2,3,6)]&gt; y = state.x77[,c(4,5)]&gt; cor(x,y)              Life Exp     MurderPopulation -0.06805195  0.3436428Income      0.34025534 -0.2300776Illiteracy -0.58847793  0.7029752HS Grad     0.58221620 -0.4879710</code></pre><p>cor函数只能计算三种算法,例如偏相关系数,多分隔系数,多系列系数,等.</p><h4 id="偏相关系数"><a href="#偏相关系数" class="headerlink" title="偏相关系数"></a>偏相关系数</h4><pre><code class="r">## 第一个参数是(前两个是要计算数值的下标,其余的是条件变量的下标),第二个参数是cov计算出来的协方差结果.&gt; ?pcor&gt; colnames(state.x77)[1] &quot;Population&quot; &quot;Income&quot;     &quot;Illiteracy&quot; &quot;Life Exp&quot;  [5] &quot;Murder&quot;     &quot;HS Grad&quot;    &quot;Frost&quot;      &quot;Area&quot; &gt; pcor(c(1,5,2,3,6),cov(state.x77))[1] 0.3462724## 计算出偏相关系数</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据分析 </category>
          
          <category> R语言数据分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>R语言与数据分析（一）</title>
      <link href="2020/06/26/r-shu-ju-fen-xi/r-yu-yan-ru-men-yu-shu-ju-fen-xi-bi-ji-yi/"/>
      <url>2020/06/26/r-shu-ju-fen-xi/r-yu-yan-ru-men-yu-shu-ju-fen-xi-bi-ji-yi/</url>
      
        <content type="html"><![CDATA[<blockquote class="blockquote-center">喜欢一件事就去争取吧。</blockquote><a id="more"></a><h2 id="1-课程介绍"><a href="#1-课程介绍" class="headerlink" title="1. 课程介绍"></a>1. 课程介绍</h2><h2 id="2-数据分析"><a href="#2-数据分析" class="headerlink" title="2. 数据分析"></a>2. 数据分析</h2><p>数据就是事物进行记录可鉴别的符号，是对客观事物性质状态以及相互关系等进行记载的物理符号。</p><p><strong>数据分析过程</strong>：</p><ol><li>数据的采集</li><li>数据的存储</li><li>数据统计：使用统计方法，有目的的对收集的数据进行分析处理，并解读分析结果。结绳、算盘、计算器、excel</li><li>数据挖掘：一般是指从大量的数据中通过算法搜索隐藏于其中的信息的过程。挖掘是一个探索的过程，统计是有目的的。</li><li>数据的可视化 </li><li>进行决策，利用统计结果进行有目的的决策</li></ol><h2 id="3-数据挖掘"><a href="#3-数据挖掘" class="headerlink" title="3. 数据挖掘"></a>3. 数据挖掘</h2><p>介绍了数据挖掘的重要性。</p><h2 id="4-数据可视化"><a href="#4-数据可视化" class="headerlink" title="4. 数据可视化"></a>4. 数据可视化</h2><p>人是视觉动物</p><h2 id="5-R语言介绍"><a href="#5-R语言介绍" class="headerlink" title="5. R语言介绍"></a>5. R语言介绍</h2><ol><li>有效的数据处理和保存机制。</li><li>拥有一整套数组和矩阵的操作运算符</li><li>一系列连贯而又完整的数据分析中间工具</li><li>图形统计可以对数据直接进行分析和显示，可用于多种图形设备</li><li>一种相当完善、简介和搞笑的程序设计语言</li><li>R语言是彻底的面向对象的统计编程语言</li><li>R语言和其他变成语言、数据库之有很好的接口</li><li>R语言是自由 的软件，功能不比任何其他同列软件差</li><li>R语言的网上资源丰富</li></ol><p>Rebolutions R 已经被微软收购了，该命为Microsoft R </p><h2 id="6-R应用的案例"><a href="#6-R应用的案例" class="headerlink" title="6. R应用的案例"></a>6. R应用的案例</h2><p>一个维生素C与牙齿生长的关系</p><p>在官网上面下载R语言的安装包，</p><h2 id="7-R语言的安装"><a href="#7-R语言的安装" class="headerlink" title="7. R语言的安装"></a>7. R语言的安装</h2><p>不着急，这个在网络上有大量的资源</p><h2 id="8-R-运行与设置"><a href="#8-R-运行与设置" class="headerlink" title="8. R 运行与设置"></a>8. R 运行与设置</h2><p>讲述了R自带的GUI</p><h2 id="9-Rstudio"><a href="#9-Rstudio" class="headerlink" title="9. Rstudio"></a>9. Rstudio</h2><p>一般都是用到了这个软件， 介绍了各种界面的操作。</p><h2 id="10-基本操作"><a href="#10-基本操作" class="headerlink" title="10 基本操作"></a>10 基本操作</h2><p>设定工作目录，查看工作目录</p><blockquote><p>getwd() </p></blockquote><p>设置工作目录，填入你的工作目录</p><blockquote><p>setwd(dir = “”)</p></blockquote><p>列出每个变量的所有信息</p><blockquote><p>ls.str() </p></blockquote><h2 id="11-R扩展包"><a href="#11-R扩展包" class="headerlink" title="11. R扩展包"></a>11. R扩展包</h2><p>查看扩展包的位置</p><blockquote><p>.libPaths()</p></blockquote><p>查看安装了哪些安装包</p><blockquote><p>library()</p></blockquote><p>一次安装多个包</p><blockquote><p>install.packages(c(“AER”,”ca”,””)</p></blockquote><h2 id="12-R包的使用"><a href="#12-R包的使用" class="headerlink" title="12 R包的使用"></a>12 R包的使用</h2><p>R软件包的组成</p><ul><li>base</li><li>datasets 存放R内置的数据集</li><li>utils R语言的工具函数</li><li>grDevices 基于base 和greph的图形设备，与绘图相关的函数都在这个包里</li><li>graphics 基于base图形的R默认的绘图函数都在这个包里</li><li>stats 存放与统计相关的函数，</li><li>methods R对象一般的定义方法和类</li><li>splines 基础包</li><li>stats4 基础包</li><li>tcltk 基础包</li></ul><p>广州,兰州,的镜像是可以用的,兰州是比较快的.</p><p>加载包</p><blockquote><p>require(vcd)</p></blockquote><p>移除加载</p><blockquote><p>detach(“package:vcd”)</p></blockquote><p>删除包</p><blockquote><p>remove.package(“vcd”)</p></blockquote><p>查看以安装的包</p><blockquote><p>installed.packages()</p></blockquote><p>查看工具包的帮助信息</p><blockquote><p>help(package=”vcd”)</p></blockquote><p>也可以用library来查看帮助信息</p><blockquote><p>library(help=”vcd”)</p></blockquote><p>列出vcd中所有包含的函数</p><blockquote><p>ls(“package:vcd”)</p></blockquote><p>列出vcd中所有的数据集</p><blockquote><p>data(package=”vcd”)</p></blockquote><h3 id="R包的批量移植"><a href="#R包的批量移植" class="headerlink" title="R包的批量移植"></a>R包的批量移植</h3><p>一种方案:</p><blockquote><p>Rpackage &lt;- installed.packages()[,1]<br>save(Rpackage,file=”Rpack.Rdata)</p></blockquote><p>列出安装包的第一列,导出到一个文本中,在另一个电脑上load加载到一个变量中,</p><blockquote><p>for (i in Rpack) install.packages(i)<br>这样就可以批量安装包了.</p></blockquote><h2 id="13-获取帮助"><a href="#13-获取帮助" class="headerlink" title="13 获取帮助"></a>13 获取帮助</h2><p>比如help()会在浏览器中打开帮助信息,和?sum一个意思</p><blockquote><p>help(sum)</p></blockquote><blockquote><p>?(sum)</p></blockquote><p>快速了解函数的参数,而不想去看文档args函数</p><blockquote><p>args(plot)</p></blockquote><p>还可以用esample 函数去示例一个函数的使用</p><blockquote><p>example(hist)</p></blockquote><p>也可以用demo 这种示例</p><blockquote><p>demo(graphic)</p></blockquote><p>用help查看包的帮助,这个是在网上查看帮助信息</p><blockquote><p>help(package=vcd)</p></blockquote><p>用vignette()函数,这个一些库可能没有这个文档,</p><blockquote><p>vignette(“vcd”)</p></blockquote><blockquote><p>??qplot</p></blockquote><p>网络搜索相关的函数</p><blockquote><p>RSiteSearch(“matlab”)</p></blockquote><p>rseek.org 是一个与R相关的论坛</p><h2 id="14-excel-案例"><a href="#14-excel-案例" class="headerlink" title="14 excel 案例"></a>14 excel 案例</h2><p>主要是excel 数据透视表的使用案例,没有数据不是很懂,老师也说了,excel也是一种很强大的数据分析工具,也可以学习excel的使用</p><h2 id="15-内置数据集"><a href="#15-内置数据集" class="headerlink" title="15 内置数据集"></a>15 内置数据集</h2><p>R内置了很多的数据集,存在于datasets这个包中</p><p>直接<code>data()</code>就可以列出很多的数据集,<code>rivers</code>可以列出北美141条河流的长度</p><p>可以用<code>help(&quot;mtcars&quot;)</code>这样的去查看数据的帮助信息</p><p>加载数据集</p><blockquote><p>data(package=”MASS”)</p></blockquote><p>这样只是加载数据集,而包就不用加载进来</p><blockquote><p>data(Chile,Package=”car”)</p></blockquote><h2 id="16-数据结构"><a href="#16-数据结构" class="headerlink" title="16 数据结构"></a>16 数据结构</h2><p>数据结构式计算机存储、组织数据的方式。数据结构是指相互之间存在一种或多种特定关系的数据元素集合。</p><p>这个是很重要的，知道是什么，知道为什么。</p><p>R中数据类型</p><ol><li>数值型，数值可以用于直接计算。</li><li>字符串型，可以进行连接，转换，提取等。</li><li>逻辑型，真假。</li><li>日期型等。</li></ol><p>这个跟Python差不多。</p><p>普通的数据结构：向量，标量，列表，数组，多维数组。</p><p>特殊数据结构：perl中的哈希，python中的字典，c语言中的指针等。</p><p>R对象：object, 他是指可以赋值给变量的任何事物，包括常量，数据结构，函数，甚至图形。对象都拥有某种模式，描述了此对象是如何存储的，以及某个类。</p><h2 id="17-向量"><a href="#17-向量" class="headerlink" title="17 向量"></a>17 向量</h2><p>向量，vector, 是R中最重要的一个概念，它是构成其他数据结构的基础，R中的向量概念和数学中的向量是不同的，类似于数学上的集合，有一个或多个元素所构成。向量其实是用于存储数值型，字符型或逻辑型数据的一维数组。</p><p>R中用函数 “c ”来创建向量。如：</p><blockquote><p>c &lt;- c(1,2,3,4)<br>z &lt;- c(TRUE,T,F)</p></blockquote><p>R中 <code>euro</code>,<code>rivers</code>,<code>state.abb</code>,<code>state.area</code>都是向量的数据结构。</p><p>等差数列,输出1到100的等差数列</p><blockquote><p>c(1:100)</p></blockquote><p>输出步长为2的等差数列</p><blockquote><p>seq (from=1,to=100,by=2)</p></blockquote><p>输出重复序列,x重复5次</p><blockquote><p>rep (“x”,5)<br>rep (x,5)</p></blockquote><p>可以用each来控制一个元素的重复次数。如下可以吧x中的元素重复5次，times可以把整数组重复2次。</p><blockquote><p>rep(x,each=5,times=2)</p></blockquote><p>如何查看数据类型，</p><blockquote><p>mode(z)</p></blockquote><p>R中向量化编程</p><blockquote><p>x &lt;- c(1,2,3,4,5)<br>y &lt;- c(6,7,8,9,10)<br>x*2+y<br>8 11 14 17 20</p></blockquote><p>在x中取出x&gt;3的值</p><blockquote><p>x[x&gt;3]</p></blockquote><p>使用rep来控制每个元素的出现次数</p><blockquote><p>rep(x,c(2,4,6,1,3))<br>输出[1] 1 1 2 2 2 2 3 3 3 3 3 3 4 5 5 5</p></blockquote><h2 id="18-向量索引"><a href="#18-向量索引" class="headerlink" title="18 向量索引"></a>18 向量索引</h2><p>在R中元素的第一个值是从 “1” 开始，不是0<code>length(x)</code>可以算出元素的个数。<br>如：x为1-100的元组</p><blockquote><p>x[c(1,23,55,32,78)]<br>[1]  1 23 54 65 输出</p></blockquote><p><strong>重要</strong>使用逻辑向量的值来进行向量的索引。比如：</p><blockquote><p>y &lt;- c(1:10)<br>y[c(T,F,T,F,T,F,T,T,T,T,T)]<br>[1]  1  3  5  7  8  9 10 NA 输出为真的数字 NA为缺失值</p></blockquote><p>又比如</p><blockquote><p>z &lt;- c(“one”,”two”, “three”, “four”, “five”)<br>z<br>[1] “one”   “two”   “three” “four”  “five”<br>z %in% c(“one”,”two”) 判断是否在z中有这个字符。<br>[1]  TRUE  TRUE FALSE FALSE FALSE</p></blockquote><p>使用元素名称进行访问，相当于字典中的键值对</p><pre><code>&gt; y &lt;- c(1:6)&gt; names(y) = c(&quot;noe&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;, &quot;five&quot;, &quot;six&quot;)&gt; y  noe   two three  four  five   six     1     2     3     4     5     6 &gt; names(y)[1] &quot;noe&quot;   &quot;two&quot;   &quot;three&quot; &quot;four&quot;  &quot;five&quot;  &quot;six&quot; &gt; y[&quot;two&quot;]two   2 </code></pre><p>append函数，可以指定在那个位置进行插值。</p><pre><code class="R">&gt; x &lt;- c(1:100)&gt; v &lt;- c(1:3)&gt; v[15] &lt;- 15&gt; v [1]  1  2  3 NA NA NA NA NA NA NA NA NA NA NA 15&gt; append(x = v, values = 50,after = 12) [1]  1  2  3 NA NA NA NA NA NA NA NA NA 50 NA NA 15&gt;</code></pre><p>删除向量可以用<code>rm()</code>函数，也可以在索引中加负号，但只是暂时的，但是可以传回原来的值</p><pre><code class="R">&gt; rm(y)&gt; y &lt;- c(1:10)&gt; y[-c(1:3)][1]  4  5  6  7  8  9 10&gt; y &lt;- y[-c(1:3)]&gt; y[1]  4  5  6  7  8  9 10</code></pre><h2 id="19-向量的运算"><a href="#19-向量的运算" class="headerlink" title="19 向量的运算"></a>19 向量的运算</h2><p>“**”为幂运算<br>“%%”求余运算<br>“%/%”为整除运算</p><p>两个元素的相加必须是相同的元素个数。python中这个还是很好解决的</p><pre><code class="R">&gt; x = c(1,2,3)&gt; y = c(1,2,4,5,6)&gt; x&gt;y[1] FALSE FALSE FALSE FALSE FALSEWarning message:In x &gt; y : 长的对象长度不是短的对象长度的整倍数&gt; c(1,2,3) %in% c(1,2,4,5,6)[1]  TRUE  TRUE FALSE</code></pre><p>其他的函数运算</p><pre><code class="R">&gt; abs(-6) 为绝对值[1] 6&gt; sqrt(25)  开方[1] 5&gt; log(16,base=2)[1] 4&gt; log2(16)  对数函数[1] 4&gt; ceiling(c(-2.3,3.1415))  返回整数部分[1] -2  4&gt; sin(x)  三角函数[1] 0.8414710 0.9092974 0.1411200&gt; vec = 1:100&gt; sum(vec)  求和函数[1] 5050&gt; range(vec)  范围，最大值和最小值[1]   1 100&gt; max(vec)  最大值[1] 100&gt; min(vec)  最小值[1] 1&gt; mean(vec)  均值[1] 50.5&gt; var(vec)  方差[1] 841.6667&gt; sd(vec)  标准差[1] 29.01149&gt; median(vec)  中位数[1] 50.5&gt; round(var(vec),digits = 2)  round默认是整数digits设置小数位数[1] 841.67&gt; prod(vec)  各元素连续乘积[1] 9.332622e+157&gt; quantile(vec,c(0.5,0.4,0.8))  分位数 50%  40%  80% 50.5 40.6 80.2</code></pre><p>寻找元素位置which,返回索引</p><pre><code class="R">&gt; t = c(1,5,4,7,2,9,6)&gt; which.max(t)[1] 6&gt; which(t==7)[1] 4</code></pre><h2 id="20-矩阵与数组"><a href="#20-矩阵与数组" class="headerlink" title="20 矩阵与数组"></a>20 矩阵与数组</h2><p>矩阵式一个按照长方阵列排列的复数或实数集合.向量是一维的,而矩阵式二维的,需要有行列.基本就跟excel中的数据表差不多.</p><p>内置矩阵数据集</p><pre><code class="R">&gt; iris3&gt; state.x77&gt; heatmap(state.x77)  热图</code></pre><p>用<code>matrix()</code>创建矩阵</p><pre><code class="R">&gt; m = matrix(1:20,4,5)  1到20,4行5列的矩阵&gt; m     [,1] [,2] [,3] [,4] [,5][1,]    1    5    9   13   17[2,]    2    6   10   14   18[3,]    3    7   11   15   19[4,]    4    8   12   16   20&gt; m = matrix(1:20,4,5,byrow = T/F) 通过行或列</code></pre><p>更改行列名称</p><pre><code class="R">&gt; rname = c(&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;)&gt; cname = c(&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;)&gt; dimnames(m) = list(rname,cname)&gt; m  1 2  3  4  51 1 5  9 13 172 2 6 10 14 183 3 7 11 15 194 4 8 12 16 20</code></pre><p><code>dim()</code>向量设定函数</p><p>设定为一个2行2列的3高的三维数组</p><pre><code class="R">&gt; x = c(1:12)&gt; x [1]  1  2  3  4  5  6  7  8  9 10 11 12 &gt; dim(x)NULL&gt; dim(x) = c(2,2,3)&gt; x, , 1     [,1] [,2][1,]    1    3[2,]    2    4, , 2     [,1] [,2][1,]    5    7[2,]    6    8, , 3     [,1] [,2][1,]    9   11[2,]   10   12</code></pre><p>如何访问二维数组的值</p><pre><code class="R">&gt; m     [,1] [,2] [,3] [,4] [,5][1,]    1    5    9   13   17[2,]    2    6   10   14   18[3,]    3    7   11   15   19[4,]    4    8   12   16   20&gt; m[2,2]  二行二列[1] 6&gt; m[2,]  二行[1]  2  6 10 14 18&gt; m[,2]  二列[1] 5 6 7 8&gt; m[-1,2]  &quot;-&quot;为去除第一列[1] 6 7 8&gt; m+1  每个元素加一     [,1] [,2] [,3] [,4] [,5][1,]    2    6   10   14   18[2,]    3    7   11   15   19[3,]    4    8   12   16   20[4,]    5    9   13   17   21</code></pre><p>行列的计算</p><pre><code class="R">&gt; colSums(m)  计算每一列的和[1] 10 26 42 58 74&gt; rowSums(m)  计算每一行的和[1] 45 50 55 60&gt; colMeans(m)  列的平均值[1]  2.5  6.5 10.5 14.5 18.5&gt; rowMeans(m)  行的平均值[1]  9 10 11 12</code></pre><p>矩阵的内外积</p><pre><code class="R">&gt; n = matrix(1:9,3,3)&gt; t = matrix(2:10,3,3)&gt; n     [,1] [,2] [,3][1,]    1    4    7[2,]    2    5    8[3,]    3    6    9&gt; t     [,1] [,2] [,3][1,]    2    5    8[2,]    3    6    9[3,]    4    7   10&gt; n*t  内积     [,1] [,2] [,3][1,]    2   20   56[2,]    6   30   72[3,]   12   42   90&gt; n %*% t  外积     [,1] [,2] [,3][1,]   42   78  114[2,]   51   96  141[3,]   60  114  168</code></pre><p>其他</p><pre><code class="R">&gt; diag(n)  对角线[1] 1 5 9&gt; diag(t)[1]  2  6 10&gt; m     [,1] [,2] [,3] [,4] [,5][1,]    1    5    9   13   17[2,]    2    6   10   14   18[3,]    3    7   11   15   19[4,]    4    8   12   16   20&gt; t(m)  行列转换     [,1] [,2] [,3] [,4][1,]    1    2    3    4[2,]    5    6    7    8[3,]    9   10   11   12[4,]   13   14   15   16[5,]   17   18   19   20</code></pre><h2 id="21-列表"><a href="#21-列表" class="headerlink" title="21-列表"></a>21-列表</h2><p>列表顾名思义就是用来存储很多内容的集合,列表和数组基本是等同的,但是在R中,列表是最复杂的一种数据结构,也是非常重要的一种数据结构.</p><p>列表中可以存储若干个向量,矩阵,数据框,甚至其他的列表组合.</p><p>向量只能存储一种数据类型,列表却可以存储多种数据类型.</p><p>比如: 其实跟Python中的list是一样的</p><pre><code class="R">&gt; a = 1:20&gt; b = matrix(1:20,4)&gt; c = mtcars&gt; d = &quot;This is a test list&quot;&gt; mlist = list(a,b,c,d)&gt; mlist[[1]] [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20[[2]]     [,1] [,2] [,3] [,4] [,5][1,]    1    5    9   13   17[2,]    2    6   10   14   18[3,]    3    7   11   15   19[4,]    4    8   12   16   20[[3]]                     mpg cyl  disp  hp drat    wt  qsec vs am gear carbMazda RX4           21.0   6 160.0 110 3.90 2.620 16.46  0  1    4    4Mazda RX4 Wag       21.0   6 160.0 110 3.90 2.875 17.02  0  1    4    4Datsun 710          22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1Hornet 4 Drive      21.4   6 258.0 110 3.08 3.215 19.44  1  0    3    1Hornet Sportabout   18.7   8 360.0 175 3.15 3.440 17.02  0  0    3    2Valiant             18.1   6 225.0 105 2.76 3.460 20.22  1  0    3    1Duster 360          14.3   8 360.0 245 3.21 3.570 15.84  0  0    3    4Merc 240D           24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2Merc 230            22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2Merc 280            19.2   6 167.6 123 3.92 3.440 18.30  1  0    4    4Merc 280C           17.8   6 167.6 123 3.92 3.440 18.90  1  0    4    4Merc 450SE          16.4   8 275.8 180 3.07 4.070 17.40  0  0    3    3Merc 450SL          17.3   8 275.8 180 3.07 3.730 17.60  0  0    3    3[[4]][1] &quot;This is a test list&quot;</code></pre><p><code>mlist[[1]]</code> 访问的数据本身,如果是一个中括号,则数据类型是一个list.所以给列表赋值的时候要两个中括号.</p><pre><code class="R">&gt; mlist[[5]] = iris  &gt; mlist[-5]  就可以删除这个索引的值</code></pre><h2 id="22-数据框"><a href="#22-数据框" class="headerlink" title="22 数据框"></a>22 数据框</h2><p>数据框是一种表格式的数据结构,</p><p>数据集通常是由数据构成的一个矩形数组,行表示观测,列表示变量.不同的行业对于数据集的行列叫法不同.</p><p>数据框实际上是一个列表.列表中的元素就是向量,这些向量构成数据框的列,每一列的长度相同,数据框的列是必须命名的.</p><p>比如excel中的数据表就是一个数据框,其中的每一列的元素格式可以不同.</p><p>矩阵的数据必须是一个类型,数据框可以不同,数据框的每一列必须是同一类型,每一行可以不同.</p><p>生成数据框</p><pre><code class="R">state = data.frame(state.name,state.abb,state.region,state.x77)</code></pre><p>数据框的访问,基本是一样的</p><pre><code class="R">&gt; state[1] 输出第一列&gt; state[c(2,4)]  输出2和4列&gt; state[,&quot;state.abb&quot;]&gt; state$state.abb  采用$符号的方式访问</code></pre><p>与plot函数使用的实例,绘制women的身高体重散点图</p><pre><code class="R">plot(women$height,women$weight) </code></pre><!--<img src="https://s1.ax1x.com/2020/05/28/teuy7t.png" alt="teuy7t.png" border="0" />--><p><img src="https://s1.ax1x.com/2020/05/28/teuy7t.png" alt="teuy7t.png"></p><h4 id="不使用-符号的各种操作"><a href="#不使用-符号的各种操作" class="headerlink" title="不使用$符号的各种操作"></a>不使用$符号的各种操作</h4><p><code>attach</code>加载与<code>detach</code>取消加载;可以在终端中直接敲数据框的名字就可以了,就可以摆脱$符号</p><pre><code class="R">&gt; attach(mtcars)&gt; mpg  数据框的名称 [1] 21.0 21.0 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 17.8 16.4 17.3 15.2 10.4[16] 10.4 14.7 32.4 30.4 33.9 21.5 15.5 15.2 13.3 19.2 27.3 26.0 30.4 15.8 19.7[31] 15.0 21.4</code></pre><p><code>with</code>函数,不过要一个一个的加载,一般还是推荐使用$符号</p><pre><code class="R">&gt; with(mtcars,&#123;hp&#125;)&gt; hp [1] 110 110  93 110 175 105 245  62  95 123 123 180 180 180 205 215 230  66  52[20]  65  97 150 150 245 175  66  91 113 264 175 335 109</code></pre><p>关于单双括号的解释,就像使火车,单括号还是访问的火车中的车厢,双括号就相当于把车厢取出来单独使用.</p><h2 id="23-因子"><a href="#23-因子" class="headerlink" title="23 因子"></a>23 因子</h2><p>R中的因子使不好理解的</p><p>变量的分类</p><ol><li>名义型变量:一般为字符串</li><li>有序型变量</li><li>连续型变量:一般为数值型</li></ol><p>在R中名义型变量和有序型变量称为因子,factor. 这些分类变量的可能值称为一个水平,level,例如good,better,best,都称为一个level. 有这些水平值构成的向量就称为因子.</p><p>因子的应用</p><ul><li>计算频数</li><li>独立性检验</li><li>相关性检验</li><li>方差分析</li><li>主成分分析</li><li>因子分析等</li></ul><p>table频数统计.cyl就是一个因子,4,6,8就是水平</p><pre><code class="R">&gt; mtcars$cyl [1] 6 6 4 6 8 6 8 4 4 6 6 8 8 8 8 8 8 4 4 4 4 8 8 8 8 4 4 4 8 6 8 4&gt; table(cyl)cyl 4  6  8 11  7 14 </code></pre><p>factor 函数可以将向量函数转换成因子,按照顺序排列</p><pre><code class="R">&gt; week = factor(c(&quot;Mon&quot;,&quot;Fri&quot;,&quot;Tuh&quot;,&quot;Wed&quot;,&quot;Mon&quot;,&quot;Fri&quot;,&quot;Sun&quot;),ordered = T,levels = c(&quot;Mon&quot;,&quot;Tue&quot;,&quot;Wed&quot;,&quot;Thu&quot;,&quot;Fri&quot;,&quot;Sat&quot;,&quot;Sun&quot;))&gt; week[1] Mon  Fri  &lt;NA&gt; Wed  Mon  Fri  Sun Levels: Mon &lt; Tue &lt; Wed &lt; Thu &lt; Fri &lt; Sat &lt; Sun</code></pre><p>水平</p><pre><code class="R">&gt; fcyl = factor(mtcars$cyl)&gt; fcyl  [1] 6 6 4 6 8 6 8 4 4 6 6 8 8 8 8 8 8 4 4 4 4 8 8 8 8 4 4 4 8 6 8[32] 4Levels: 4 6 8</code></pre><p>通过水平绘制柱状图,可以很好的进行频数统计</p><pre><code class="R">&gt; fcyl = factor(mtcars$cyl)&gt; fcyl  [1] 6 6 4 6 8 6 8 4 4 6 6 8 8 8 8 8 8 4 4 4 4 8 8 8 8 4 4 4 8 6 8[32] 4Levels: 4 6 8&gt; plot(fcyl )</code></pre><!--<img src="https://s1.ax1x.com/2020/06/01/t861js.png" alt="t861js.png" border="0" />--><p><img src="https://s1.ax1x.com/2020/06/01/t861js.png" alt="t861js.png"></p><pre><code class="R">&gt; num = 1:100&gt; cut(num,c(seq(0,100,10)))  [1] (0,10]   (0,10]   (0,10]   (0,10]   (0,10]   (0,10]   (0,10]   (0,10]   (0,10]   (0,10]   (10,20]  (10,20]  (10,20]  (10,20]  (10,20]  [16] (10,20]  (10,20]  (10,20]  (10,20]  (10,20]  (20,30]  (20,30]  (20,30]  (20,30]  (20,30]  (20,30]  (20,30]  (20,30]  (20,30]  (20,30]  ...</code></pre><p>state.divsion和state.region,也是factor的内置数据</p><h2 id="24-缺失数据"><a href="#24-缺失数据" class="headerlink" title="24-缺失数据"></a>24-缺失数据</h2><p>缺失数据可分为</p><ul><li>完全随机缺失</li><li>随机缺失</li><li>非随机缺失<br>缺失可能是设备故障,测量的问题导致的</li></ul><p><code>NA</code>表示缺失not available的简称,不是没有值,知识未知的数值.</p><p>统计的时候跳过缺失值,但是平均值的时候还是按照全部的值的个数计算的.</p><pre><code class="R">&gt; a = c(NA,1:49)&gt; sum(a)[1] NA&gt; sum(a,na.rm = TRUE)[1] 1225&gt; mean(a,na.rm = TRUE)[1] 25</code></pre><p>用<code>na.omit()</code>去除缺失值</p><pre><code class="R">&gt; c = c(NA,1:20,NA,NA)&gt; c [1] NA  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20[22] NA NA&gt; d = na.omit(c)&gt; d [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20attr(,&quot;na.action&quot;)[1]  1 22 23attr(,&quot;class&quot;)[1] &quot;omit&quot;</code></pre><h4 id="其他缺失数据"><a href="#其他缺失数据" class="headerlink" title="其他缺失数据"></a>其他缺失数据</h4><ol><li>缺失数据NaN,代表不可能的值;</li><li>Inf表示无穷,分为正无穷Inf和负无穷Inf,代表无穷大或者无穷小.</li><li>Inf存在,是无穷大后者无穷小,但是表示不可能的值.</li></ol><ul><li>可以用<code>is.nan()</code>来识别不可能值</li><li>可以用<code>is.infinite()</code>来识别无穷值</li></ul><h2 id="25-字符串"><a href="#25-字符串" class="headerlink" title="25-字符串"></a>25-字符串</h2><p>R中可用的正则表达式</p><!--<img src="https://s1.ax1x.com/2020/06/01/tJHIUS.png" alt="tJHIUS.png" border="0" />--><p><img src="https://s1.ax1x.com/2020/06/01/tJHIUS.png" alt="tJHIUS.png"></p><p>统计字符串的长度,包括字符串</p><pre><code class="R">&gt; nchar(&quot;hello world&quot;)[1] 11&gt; nchar(month.name)  ## 可以返回向量的每个元素的长度,length不可以 [1] 7 8 5 5 3 4 4 6 9 7 8 8&gt; length(month.name)[1] 12</code></pre><p><code>paste()</code>可以把字符串相连</p><pre><code class="R">### paste() 后面的参数都会与变量的每个元素连接&gt; name = c(&quot;Moe&quot;,&quot;Larry&quot;,&quot;Curly&quot;)&gt; paste(name,&quot;loves stats&quot;)[1] &quot;Moe loves stats&quot;   &quot;Larry loves stats&quot; &quot;Curly loves stats&quot;</code></pre><p>用<code>substr()</code>提取字符,可以提取每一个元素的字符</p><pre><code class="R">### start 表示起始位置,stop表示终止位置&gt; substr(x = month.name,start = 1,stop = 3) [1] &quot;Jan&quot; &quot;Feb&quot; &quot;Mar&quot; &quot;Apr&quot; &quot;May&quot; &quot;Jun&quot; &quot;Jul&quot; &quot;Aug&quot; &quot;Sep&quot; &quot;Oct&quot;[11] &quot;Nov&quot; &quot;Dec&quot;</code></pre><p>大小写<code>tolower()</code>和<code>toupper()</code>和首字母大写</p><pre><code class="R">&gt; temp = substr(x = month.name,start = 1,stop = 3)&gt; temp [1] &quot;Jan&quot; &quot;Feb&quot; &quot;Mar&quot; &quot;Apr&quot; &quot;May&quot; &quot;Jun&quot; &quot;Jul&quot; &quot;Aug&quot; &quot;Sep&quot; &quot;Oct&quot;[11] &quot;Nov&quot; &quot;Dec&quot;&gt; tolower(temp) [1] &quot;jan&quot; &quot;feb&quot; &quot;mar&quot; &quot;apr&quot; &quot;may&quot; &quot;jun&quot; &quot;jul&quot; &quot;aug&quot; &quot;sep&quot; &quot;oct&quot;[11] &quot;nov&quot; &quot;dec&quot;&gt; toupper(temp) [1] &quot;JAN&quot; &quot;FEB&quot; &quot;MAR&quot; &quot;APR&quot; &quot;MAY&quot; &quot;JUN&quot; &quot;JUL&quot; &quot;AUG&quot; &quot;SEP&quot; &quot;OCT&quot;[11] &quot;NOV&quot; &quot;DEC&quot;### 首字母大写不是很好解决,可以用正则替换，perl = T表示支持perl语言的正则表达式&gt; gsub(&quot;^(\\w)&quot;,&quot;\\L\\1&quot;,tolower(temp),perl = T) [1] &quot;jan&quot; &quot;feb&quot; &quot;mar&quot; &quot;apr&quot; &quot;may&quot; &quot;jun&quot; &quot;jul&quot; &quot;aug&quot; &quot;sep&quot; &quot;oct&quot;[11] &quot;nov&quot; &quot;dec&quot;&gt; gsub(&quot;^(\\w)&quot;,&quot;\\U\\1&quot;,tolower(temp),perl = T) [1] &quot;Jan&quot; &quot;Feb&quot; &quot;Mar&quot; &quot;Apr&quot; &quot;May&quot; &quot;Jun&quot; &quot;Jul&quot; &quot;Aug&quot; &quot;Sep&quot; &quot;Oct&quot;[11] &quot;Nov&quot; &quot;Dec&quot;</code></pre><p><code>grep()</code>可以用来搜索字符串,其次还有<code>match()</code></p><pre><code class="R">&gt; x = c(&quot;b&quot;,&quot;A+&quot;,&quot;AC&quot;)&gt; grep(&quot;b&quot;,x,fixed = T)[1] 1</code></pre><p><code>strsplit()</code>可以用来分割字符串,返回一个列表,跟Python一个意思</p><pre><code class="R">&gt; path = &quot;/usr/local/bin/R&quot;&gt; strsplit(path,&quot;/&quot;)[[1]][1] &quot;&quot;      &quot;usr&quot;   &quot;local&quot; &quot;bin&quot;   &quot;R&quot;  </code></pre><p>后语:正则表达式是很重要的技能</p><p>附赠技能:随机字符串,比如生成一副扑克牌</p><pre><code class="r">&gt; face = 1:13&gt; suit = c(&quot;spades&quot;,&quot;clubs&quot;,&quot;hearts&quot;,&quot;diamonds&quot;)### FUN表示接一个函数,这里是连接函数,sep表示连接符号&gt; outer(suit,face,FUN = paste,sep=&quot;-&quot;)     [,1]         [,2]         [,3]         [,4]        [1,] &quot;spades-1&quot;   &quot;spades-2&quot;   &quot;spades-3&quot;   &quot;spades-4&quot;  [2,] &quot;clubs-1&quot;    &quot;clubs-2&quot;    &quot;clubs-3&quot;    &quot;clubs-4&quot;   [3,] &quot;hearts-1&quot;   &quot;hearts-2&quot;   &quot;hearts-3&quot;   &quot;hearts-4&quot;  [4,] &quot;diamonds-1&quot; &quot;diamonds-2&quot; &quot;diamonds-3&quot; &quot;diamonds-4&quot;     [,5]         [,6]         [,7]         [,8]        [1,] &quot;spades-5&quot;   &quot;spades-6&quot;   &quot;spades-7&quot;   &quot;spades-8&quot;  [2,] &quot;clubs-5&quot;    &quot;clubs-6&quot;    &quot;clubs-7&quot;    &quot;clubs-8&quot;   [3,] &quot;hearts-5&quot;   &quot;hearts-6&quot;   &quot;hearts-7&quot;   &quot;hearts-8&quot;  [4,] &quot;diamonds-5&quot; &quot;diamonds-6&quot; &quot;diamonds-7&quot; &quot;diamonds-8&quot;     [,9]         [,10]         [,11]         [,12]        [1,] &quot;spades-9&quot;   &quot;spades-10&quot;   &quot;spades-11&quot;   &quot;spades-12&quot;  [2,] &quot;clubs-9&quot;    &quot;clubs-10&quot;    &quot;clubs-11&quot;    &quot;clubs-12&quot;   [3,] &quot;hearts-9&quot;   &quot;hearts-10&quot;   &quot;hearts-11&quot;   &quot;hearts-12&quot;  [4,] &quot;diamonds-9&quot; &quot;diamonds-10&quot; &quot;diamonds-11&quot; &quot;diamonds-12&quot;     [,13]        [1,] &quot;spades-13&quot;  [2,] &quot;clubs-13&quot;   [3,] &quot;hearts-13&quot;  [4,] &quot;diamonds-13&quot;</code></pre><h2 id="26-日期和时间"><a href="#26-日期和时间" class="headerlink" title="26-日期和时间"></a>26-日期和时间</h2><p><strong>主要两点</strong>:</p><ol><li>对时间序列的描述;一段时间内发生了什么.</li><li>利用前面的结果预测,预测接下来要发生什么.</li></ol><p>R包的分类中Task Views有很多的处理时间分析的包</p><p><code>airmiles</code>内置数据集就是一个专门的Time Series:的时间数据集.</p><p><code>Sys.Date()</code>可以显示现在的时间</p><p>格式化日期类型</p><pre><code class="r">&gt; a = &quot;2017-01-01&quot;  ## 这是一个字符串类型&gt; as.Date(a,format = &quot;%Y-%m-%d&quot;)[1] &quot;2017-01-01&quot;&gt; class(as.Date(a,format = &quot;%Y-%m-%d&quot;))[1] &quot;Date&quot;  ## 这是一个日期类型</code></pre><p>更多格式化日期的参数可以查看<code>?strftime</code></p><p>可以用<code>seq()</code>创建一个连续的时间序列，创建连续的时间点:</p><pre><code class="r">&gt; seq(as.Date(&quot;2017-01-01&quot;),as.Date(&quot;2017-07-05&quot;),by=5) [1] &quot;2017-01-01&quot; &quot;2017-01-06&quot; &quot;2017-01-11&quot; [4] &quot;2017-01-16&quot; &quot;2017-01-21&quot; &quot;2017-01-26&quot; [7] &quot;2017-01-31&quot; &quot;2017-02-05&quot; &quot;2017-02-10&quot;[10] &quot;2017-02-15&quot; &quot;2017-02-20&quot; &quot;2017-02-25&quot;[13] &quot;2017-03-02&quot; &quot;2017-03-07&quot; &quot;2017-03-12&quot;[16] &quot;2017-03-17&quot; &quot;2017-03-22&quot; &quot;2017-03-27&quot;[19] &quot;2017-04-01&quot; &quot;2017-04-06&quot; &quot;2017-04-11&quot;[22] &quot;2017-04-16&quot; &quot;2017-04-21&quot; &quot;2017-04-26&quot;[25] &quot;2017-05-01&quot; &quot;2017-05-06&quot; &quot;2017-05-11&quot;[28] &quot;2017-05-16&quot; &quot;2017-05-21&quot; &quot;2017-05-26&quot;[31] &quot;2017-05-31&quot; &quot;2017-06-05&quot; &quot;2017-06-10&quot;[34] &quot;2017-06-15&quot; &quot;2017-06-20&quot; &quot;2017-06-25&quot;[37] &quot;2017-06-30&quot; &quot;2017-07-05&quot;</code></pre><p>随机生成48个数字</p><p>介绍了ts函数</p><h2 id="27-常见错误"><a href="#27-常见错误" class="headerlink" title="27-常见错误"></a>27-常见错误</h2><h4 id="问题"><a href="#问题" class="headerlink" title="问题:"></a>问题:</h4><ul><li>等号问题,复制操作,<code>==</code>表示判断是否相等</li><li>赋值问题</li><li>c函数问题</li><li>括号的问题</li><li>引号问题,引号内的一边为字符</li><li>安装包的时候要加引号<code>install.packages(&quot;gclus&quot;)</code></li><li>逗号问题,起一个分割作用</li><li>在windows中路径<code>/</code>为R中的转义符</li><li>包是需要载入的,</li><li>R中严格区分大小写</li></ul><h4 id="解决问题方法"><a href="#解决问题方法" class="headerlink" title="解决问题方法"></a>解决问题方法</h4><ul><li>google</li><li>Rblogger</li><li>quickR</li><li>stackoverflow等</li></ul><h2 id="28-获取数据"><a href="#28-获取数据" class="headerlink" title="28-获取数据"></a>28-获取数据</h2><p>获取途径:</p><ul><li>利用键盘来输入数据;</li><li>读取存储在外部的数据;</li><li>通过访问数据框系统来获取数据;</li></ul><p>前面的都不主流,主要是访问外部的文件,或者数据框的信息</p><p>通过ODBC 访问数据库,相当于数据库的一个驱动.<br><code>install.packages(&quot;RODBC&quot;)</code>就可以安装了,但是我这里报错了</p><p>这里讲的不是很详细</p><h2 id="29-读取文件-一"><a href="#29-读取文件-一" class="headerlink" title="29-读取文件(一)"></a>29-读取文件(一)</h2><p>R几乎可以读取所有的数据文件</p><p><code>setwd(dir)</code>来设置工作目录;<br>在工作目录下<code>x = read.table(&quot;input.txt&quot;)</code>就可以读取文件了,这里只是读取到内存中.</p><pre><code class="r">&gt; x = read.table(&quot;c:/Users/theing/Desktop/input.txt&quot;)  ## 这样也可以读取文件信息&gt; head(x)  ## 显示头部的信息&gt; tail(x,n=10)  ## 显示尾部的10行信息&gt; x = read.table(&quot;input.csv&quot;,sep=&quot;,&quot;)  ## 可以读取以&quot;,&quot;分割的csv文件&gt; x = read.csv(&quot;input.csv&quot;)  ## 这个一样的效果</code></pre><p><code>read.table()</code>的参数</p><ul><li>skip=5 可以跳过前面的行,从第六行读取数据</li><li>nrows=100 这样可以只读取前面100行.可以和skip 配合使用</li><li>na.strings 处理缺失值,</li><li>stringsAsFactors=False 用来控制字符串是否转换成因子,R会默认的将字符串转换成因子.所以要设置成false</li></ul><h2 id="30-读取文件-二"><a href="#30-读取文件-二" class="headerlink" title="30-读取文件(二)"></a>30-读取文件(二)</h2><p>read.table 也可以读取网络连接</p><p>老师展示了很多被墙了的链接,估计也是在暗示着什么</p><p>其次还介绍了foreign包,</p><p>如何搜索R的相关包</p><pre><code class="r">&gt; RSiteSearch(&quot;Matlab&quot;)檢索查詢疑問已被提交给http://search.r-project.org计算结果应很快就在瀏覽器里打开</code></pre><p>读取剪切板的内容,</p><pre><code class="r">## 比如你在excel中复制了一部分内容,就可以用这个功能## readCliboard() 就是读取剪切板的内容.&gt; x = read.table(&quot;clipboard&quot;,header = T,sep=&quot;\t&quot;)</code></pre><p>读取一个压缩文本的文件,R也是可以直接读取的</p><pre><code class="r">&gt; read.table(gzfile(&quot;input.txt.gz&quot;)</code></pre><p>如果遇到不标准的文件格式,可以用<code>readlines</code>和<code>scan</code></p><pre><code class="r">## 可以限制读入的行数&gt; readLines(&quot;input.csv&quot;,n=15)&gt; ?scan可以查看帮助</code></pre><h2 id="31-写入文件"><a href="#31-写入文件" class="headerlink" title="31-写入文件"></a>31-写入文件</h2><p>基本就是使用<code>write</code>函数</p><pre><code class="r">&gt; write(x,file = &quot;x.txt&quot;)</code></pre><p>可以用,基本和Python类似。</p><pre><code class="r">## sep 表示分隔符，row.name 表示行号&gt; write.table(x,file = &quot;c:/sld/sdl/x.csv&quot;,sep = &quot;,&quot;,row.name = FALSE)</code></pre><p>直接写成压缩文件,比如</p><pre><code class="r">&gt; write.table(mtcars,gzfile(&quot;newfile.txt.gz&quot;)</code></pre><h2 id="32-读取excel文件"><a href="#32-读取excel文件" class="headerlink" title="32-读取excel文件"></a>32-读取excel文件</h2><p>excel也是一个很好的数据统计文件,大多时候别人都是excel,所以还是应该掌握处理excel的能力.</p><p>excel倒过来的时候用的csv格式</p><p>XLConnect包,excel包含工作簿和工作表,称为workbook,可以直接打开xlsx的文件, 注意这个包是需要安装java环境.个人觉得这个没必要,能用excel处理就用excel处理.</p><pre><code class="r">&gt; ex = loadWorkbook(&quot;data.xlsx&quot;)&gt; readWorksheet(ex,1)  ## 1表示查看的第一个工作表&gt; ?readWorksheet  ##查看具体的功能介绍</code></pre><p>编辑excel</p><p>分四步法</p><ul><li>用loadWorkbook创建一个工作簿</li><li>工作簿中创建工作表</li><li>用writeWorksheet工具把数据保存到工作表中</li><li>用seveWorkbook保存为excel文件<pre><code class="r">&gt; wb = loadWorkbook(&quot;file.xlsx&quot;,create = T)&gt; createSheet(wb,&quot;Sheet 1&quot;)&gt; wtiteWorksheet(wb,data=mtcars,sheet = &quot;Sheet1&quot;)&gt; seveWorkbook(wb)</code></pre>查看XLConnet的详细介绍<pre><code class="r">vignette(&quot;XLConnect&quot;)</code></pre></li></ul><p>xlsx包的使用</p><pre><code class="r">## 读取第一个工作表的1到100行的内容,sheetName指明工作表的名称.append是否追加写入(新的文件,还是更改表格).&gt; library(xlsx)&gt; read.xlsx(&quot;data.xlsx&quot;,1,startRow = 1,endRow = 100)&gt; write.xlsx(x,file = &quot;rdata.xlsx&quot;,sheetName = &quot;Sheet 1&quot;,append = F)</code></pre><h2 id="33-读写R格式的文档"><a href="#33-读写R格式的文档" class="headerlink" title="33-读写R格式的文档"></a>33-读写R格式的文档</h2><p>R有两种格式的文件,Rdata和RDS</p><p>RDS文件</p><pre><code class="r">&gt; saveRDS(iris,file=&quot;iris.RDS&quot;)&gt; readRDS(&quot;iris.RDS&quot;)</code></pre><p>Rdata 文件,项目文件,使用load()加载,一般双击就可以打开了.</p><pre><code class="r">## 示例&gt; load(&quot;.RData&quot;)&gt; save(iris,iris3,file = &quot;c:/Users/theing/Desktop/iris.Rdata&quot;)</code></pre><p>保存镜像</p><pre><code class="r">save.image()</code></pre><h2 id="34-数据转换"><a href="#34-数据转换" class="headerlink" title="34-数据转换"></a>34-数据转换</h2><p>数据的收集和存储已经会了,这里开始数据的转换,转换后就可以分析数据了.</p><p>前面介绍是向量,矩阵,数组,数据框,列表,因子,时间序列,等的增删改查</p><pre><code class="r">&gt; cars32 = read.csv(&quot;mtcars.csv&quot;)&gt; is.data.frame(cars32)[1] TRUE  ## 表示是一个矩阵&gt; is.data.frame(state.x77)[1] FALSE</code></pre><p>转换为数据框</p><pre><code class="r">&gt; dstate.x77 = as.data.frame(state.x77)</code></pre><p>转换为矩阵,变为字符串类型的矩阵</p><pre><code class="r">&gt; as.matrix(data.frame(state.region,state.x77))</code></pre><p>methods查看内容</p><pre><code class="r">&gt; methods(is)&gt; methods(as)</code></pre><h4 id="向量是R种基本的数据类型-加上一个维度就是数组或者矩阵"><a href="#向量是R种基本的数据类型-加上一个维度就是数组或者矩阵" class="headerlink" title="向量是R种基本的数据类型,加上一个维度就是数组或者矩阵"></a>向量是R种基本的数据类型,加上一个维度就是数组或者矩阵</h4><pre><code class="r">## &gt; is.data.frame(state.x77)[1] FALSE&gt; x = state.abb&gt; dim(x) = c(5,10)## 向量变因子&gt; x = state.babb&gt; as.factor(x)## 变为列表&gt; as.list(x)</code></pre><p>添加一个数据框</p><pre><code class="r">&gt; state = data.frame(x,state.region,state.x77)</code></pre><h2 id="35-数据转换-二"><a href="#35-数据转换-二" class="headerlink" title="35-数据转换(二)"></a>35-数据转换(二)</h2><p>讲一个取子集的操作</p><pre><code class="r">## 这是一个数据框&gt; who = read.csv(&quot;WHO.csv&quot;,header = T)&gt; who1 = who[c(1:50),c(1:10)]&gt; who2 = who[c(1,3,5,8),c(2,14,16)]</code></pre><p>取出CountryID 在50到100的国家,似乎不知道怎么去理解</p><pre><code class="r">&gt; who4 = who[which,(who$CountryID &gt; 50 &amp; who$CountryID &lt;=100)]&gt; who4 = subset(who,who$CountryID &gt; 50 &amp; who$CountryID &lt;=100)</code></pre><p>sample抽样,机器学习中抽取两份样本,一份用来建模,一份用来验证模型的有效性</p><pre><code class="r">&gt; ?sample## 例子,第一个参数为是选择那个向量,第二个是要抽取的个数,replace 表示是否放回式的抽样.&gt; x = 1:100&gt; sample(x,30,replace = T) [1] 39 23 11 26 50 86 86 71 26  6 10 93 81 73 74 87 98[18]  6 17 87 10 69 51 24 22 70 33 68 97 82&gt; sort(sample(x,30,replace = T)) [1]  8 19 23 23 28 31 32 40 40 42 50 50 50 51 52 55 58[18] 60 63 70 73 77 78 83 83 84 85 89 93 96</code></pre><p>sample对数据框进行抽样,取子集</p><pre><code class="r">&gt; who[sample(who$CountryID,30,replace = F),]</code></pre><p>删除固定行的数据</p><pre><code class="r">## 注意逗号的位置&gt; mtcars[-1:-5,]## 清空这一行的数据&gt; mtcars$mpg = NULL </code></pre><p>如果遇到几个数据表进行汇总,这里要用到数据框的合并,可以使用cbind和rbind函数,cbind添加一列,rbind添加一行.</p><p>cbind合并列</p><pre><code class="r">## USArrests是一个数据集,state.division是一个因子&gt; cbind(USArrests,state.division)</code></pre><p>rbind合并行,这个比较麻烦,需要所有的列有源数据集有相同的列名</p><pre><code class="r">## 取出前20行和尾20行合并&gt; data1 = head(USArrests,20)&gt; data2 = head(USArrests,20)&gt; b = rbind(data1,data2)</code></pre><p>cbind和rbind也可以用于矩阵</p><p>回顾rownames可以取出行名</p><p>判断向量和数据框中哪些是重复值</p><pre><code class="r">&gt; duplicated(who)</code></pre><p>用unique(data4)可以一步取出重复项</p><h2 id="36-收据转换-三"><a href="#36-收据转换-三" class="headerlink" title="36-收据转换(三)"></a>36-收据转换(三)</h2><p>R中行列的调换,excel中可以复制后选择性粘贴.R中可以用<code>t()</code>函数实现转换</p><pre><code class="r">&gt; sractm = t(mtcars)</code></pre><p>单独一行的反转,生物序列中很常见,主要是反向互补,可以使用rev函,reverse的意思 </p><pre><code class="r">&gt; letters [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; &quot;j&quot; &quot;k&quot; &quot;l&quot;[13] &quot;m&quot; &quot;n&quot; &quot;o&quot; &quot;p&quot; &quot;q&quot; &quot;r&quot; &quot;s&quot; &quot;t&quot; &quot;u&quot; &quot;v&quot; &quot;w&quot; &quot;x&quot;[25] &quot;y&quot; &quot;z&quot;&gt; rev(letters) [1] &quot;z&quot; &quot;y&quot; &quot;x&quot; &quot;w&quot; &quot;v&quot; &quot;u&quot; &quot;t&quot; &quot;s&quot; &quot;r&quot; &quot;q&quot; &quot;p&quot; &quot;o&quot;[13] &quot;n&quot; &quot;m&quot; &quot;l&quot; &quot;k&quot; &quot;j&quot; &quot;i&quot; &quot;h&quot; &quot;g&quot; &quot;f&quot; &quot;e&quot; &quot;d&quot; &quot;c&quot;[25] &quot;b&quot; &quot;a&quot;</code></pre><p>数据框中的数据反转,思路就是,提取行名,反转,以反转后的行名为索引</p><pre><code>&gt; rowname(women)</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据分析 </category>
          
          <category> R语言数据分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>anaconda常用命令</title>
      <link href="2020/02/26/chang-yong-ming-ling/anaconda-chang-yong-ming-ling/"/>
      <url>2020/02/26/chang-yong-ming-ling/anaconda-chang-yong-ming-ling/</url>
      
        <content type="html"><![CDATA[<blockquote class="blockquote-center">anaconda 一些常用命令和设置，如有不全请告知添加。</blockquote><a id="more"></a><h3 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h3><pre><code>conda update condaconda update anacondaconda update anaconda-navigator    //update最新版本的anaconda-navigator   </code></pre><h3 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h3><p>用户权限在自己用户目录下删除anaconda生成的文件夹就可以了。</p><p>root用户要在/root/中找到anaconda 生成的文件夹，提权删掉。<br><code>rm -rf anaconda</code></p><h3 id="conda-基本命令"><a href="#conda-基本命令" class="headerlink" title="conda 基本命令"></a>conda 基本命令</h3><pre><code>conda update -n base conda        //update最新版本的condaconda create -n xxxx python=3.5   //创建python3.5的xxxx虚拟环境conda activate xxxx               //开启xxxx环境conda deactivate                  //关闭环境conda env list                    //显示所有的虚拟环境</code></pre><h3 id="导出该环境依赖"><a href="#导出该环境依赖" class="headerlink" title="导出该环境依赖"></a>导出该环境依赖</h3><p>名字随意，但是要用yml为扩展名，xml事另一种语言</p><blockquote><p>conda env export &gt; environment.yml </p></blockquote><p>安装环境依赖包，需要输入yml文件的路径</p><blockquote><p>conda env create -f environment.yml</p></blockquote><h3 id="conda-导出依赖包"><a href="#conda-导出依赖包" class="headerlink" title="conda 导出依赖包"></a>conda 导出依赖包</h3><p>conda批量导出包含环境中所有组件的requirements.txt文件</p><blockquote><p>conda list -e &gt; requirements.txt</p></blockquote><p>pip批量安装requirements.txt文件中包含的组件依赖</p><blockquote><p>conda install –yes –file requirements.txt</p></blockquote><h3 id="conda环境种更新包"><a href="#conda环境种更新包" class="headerlink" title="conda环境种更新包"></a>conda环境种更新包</h3><blockquote><p>conda update “包”</p></blockquote><blockquote><p>conda update –all</p></blockquote><h3 id="conda更换国内源"><a href="#conda更换国内源" class="headerlink" title="conda更换国内源"></a>conda更换国内源</h3><p>我一般都是用清华源，因为anaconda禁用过一段时间，清华是第一个恢复使用的，留下了好印象</p><p><a href="https://mirrors.tuna.tsinghua.edu.cn/help/anaconda/">连接</a></p><h3 id="pip-导出包"><a href="#pip-导出包" class="headerlink" title="pip 导出包"></a>pip 导出包</h3><p>pip 导出与安装依赖包<br>导出依赖包</p><blockquote><p>pip freeze &gt; requirements.txt</p></blockquote><p>安装依赖包</p><blockquote><p>pip install -r requirements.txt</p></blockquote><h3 id="pip临时源应用"><a href="#pip临时源应用" class="headerlink" title="pip临时源应用"></a>pip临时源应用</h3><blockquote><p>pip install -i <a href="https://pypi.tuna.tsinghua.edu.cn/simple">https://pypi.tuna.tsinghua.edu.cn/simple</a> docker-compose</p></blockquote><h3 id="pip设置国内源"><a href="#pip设置国内源" class="headerlink" title="pip设置国内源"></a>pip设置国内源</h3><blockquote><p>pip config set global.index-url <a href="https://mirrors.aliyun.com/pypi/simple/">https://mirrors.aliyun.com/pypi/simple/</a></p></blockquote><h3 id="其他pip源"><a href="#其他pip源" class="headerlink" title="其他pip源"></a>其他pip源</h3><pre><code># 豆瓣https://pypi.doubanio.com/simple/# 阿里云    https://mirrors.aliyun.com/pypi/simple/# 清华大学https://pypi.tuna.tsinghua.edu.cn/simple/https://mirrors.tuna.tsinghua.edu.cn/pypi/web/simple/</code></pre><h3 id="更新卸载安装包"><a href="#更新卸载安装包" class="headerlink" title="更新卸载安装包"></a>更新卸载安装包</h3><h3 id="删除虚拟环境"><a href="#删除虚拟环境" class="headerlink" title="删除虚拟环境"></a>删除虚拟环境</h3><pre><code>conda remove -n xxxx --all //创建xxxx虚拟环境</code></pre><h3 id="清理（conda瘦身）"><a href="#清理（conda瘦身）" class="headerlink" title="清理（conda瘦身）"></a>清理（conda瘦身）</h3><p><code>conda clean</code>就可以轻松搞定！第一步：通过<code>conda clean -p</code>来删除一些没用的包，这个命令会检查哪些包没有在包缓存中被硬依赖到其他地方，并删除它们。第二步：通过<code>conda clean -t</code>可以将conda保存下来的tar包。</p><pre><code>conda clean -p      //删除没有用的包conda clean -t      //tar打包</code></pre><h3 id="jupyter-notebook默认工作目录设置"><a href="#jupyter-notebook默认工作目录设置" class="headerlink" title="jupyter notebook默认工作目录设置"></a>jupyter notebook默认工作目录设置</h3><p>1）在Anaconda Prompt终端中输入下面命令，查看你的notebook配置文件在哪里：</p><pre><code>jupyter notebook --generate-config//会生成文件C:\Users\用户\.jupyter\jupyter_notebook_config.py</code></pre><p>2）打开<code>jupyter_notebook_config.py</code>文件通过搜索关键词：<code>c.NotebookApp.notebook_dir</code>，修改如下</p><pre><code>c.NotebookApp.notebook_dir = &#39;E:\\tf_models&#39;     //修改到自定义文件夹</code></pre><p>3）然后重启notebook服务器就可以了<br>注：其它方法直接命令到指定目录，Anaconda Prompt终端中输：jupyter notebook 目录地址</p><h3 id="使用conda-base环境为系统环境"><a href="#使用conda-base环境为系统环境" class="headerlink" title="使用conda base环境为系统环境"></a>使用conda base环境为系统环境</h3><p>conda config –set report_errors false/true</p>]]></content>
      
      
      
        <tags>
            
            <tag> 备忘 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于营养</title>
      <link href="2020/02/26/he-jiu-chi-rou/guan-yu-ying-yang/"/>
      <url>2020/02/26/he-jiu-chi-rou/guan-yu-ying-yang/</url>
      
        <content type="html"><![CDATA[<blockquote class="blockquote-center">这个问题也思考了很久，藏在心底也很久，但是一直没有时间去理解思考。</blockquote><a id="more"></a><p>从这个我就想到了一个问题，就是关于营养和发育的问题，以前基本是忽视了这个问题，在老师提来起来的时候我才想到，逐渐的发现这个营养是很重要的，有些东西并不是努力才可以实现的</p><p>就像王者荣耀里陈咬金的台词，强壮的身体和精神，有没有发现不吃早饭的人意志力都是比较差的，同时这些人身体和肤色也不是很好。</p><h2 id="观察中的问题"><a href="#观察中的问题" class="headerlink" title="观察中的问题"></a>观察中的问题</h2><h3 id="对初中的时候"><a href="#对初中的时候" class="headerlink" title="对初中的时候"></a>对初中的时候</h3><p>因为我每天都要锻炼，确实是这样，我相比于班上的一些人是比较活跃的，回答问题也是比较积极的，初中的时候因为爸爸的一句话，“每天晚上做几个俯卧撑，一天多做一个”，我坚持锻炼了好几年，每天晚上都会做俯卧撑，到最后甚至一晚上做200多个俯卧撑，然后就有了极限，当时并不知道怎么科学的锻炼，只知道做的越多越好，具体哪里好也不知道。因为我每天都要锻炼，我相比于班上的一些人是比较活跃的，但是也出现了一些问题就是，我因为过度的锻炼身体而耗去了大量的营养，导致身体发育不良。</p><h3 id="高中读书的时候"><a href="#高中读书的时候" class="headerlink" title="高中读书的时候"></a>高中读书的时候</h3><p>在我高中读书的的时候，因为一些原因，，，<br>由于营养没有跟上，经常上课精神恍惚，不能集中注意力，<br>记得读书的时候，明明精神很好，但是一张卷子做不完，做到最后的时候眼睛就乱转，模糊，不能很好的集中注意力，当时不知道为什么，只是觉得自己好笨啊，但是当我精神好的时候去做最后的题目又觉得不是很难，，</p><h3 id="大学读书的时候"><a href="#大学读书的时候" class="headerlink" title="大学读书的时候"></a>大学读书的时候</h3><p>就是我在杨职读书的时候发现的一个问题：</p><p>就是西农的学生普遍是比较高大的，少部分身材比较矮瘦。说白了就是整体素质比较高，杨凌这个地方学生还是很多的，当一群人走过来的时候，你通过眼神气势就可以看出西农的学生和杨职的学生，差别是很大的，西农的学生普遍很高大，观察人的时候眼神是不一样；然后我就开始思考这个问题了，真的这么巧合？真的是我没有努力？真的是我很笨？真的是基因问题？</p><h2 id="对于营养的思考"><a href="#对于营养的思考" class="headerlink" title="对于营养的思考"></a>对于营养的思考</h2><h3 id="动物的共性"><a href="#动物的共性" class="headerlink" title="动物的共性"></a>动物的共性</h3><p>以前也经常看人与自然，为什么我们见到的动物领袖总是身材高大的，要战胜领袖就要进行挑战，挑战无非就只有打架，打架当然就是身材高大的哪一方更容易赢，赢了后就更有威慑性，这是刻在我们基因里的东西，所以当我们面对一个四肢发达头脑简单的人和你对峙的时候，身材瘦小却智商高的人会立即认怂，顶多会在背后嘟囔“四肢发达头脑简单的呆瓜”</p><h3 id="瘦小的人更喜欢思考"><a href="#瘦小的人更喜欢思考" class="headerlink" title="瘦小的人更喜欢思考"></a>瘦小的人更喜欢思考</h3><p>其实很多时候我也会观察到，就是身体瘦小的人似乎活动量更多，经过查阅，实际上身体瘦小的人确实是普遍比肥胖者智商更高，神经系统更发达，更喜欢思考问题，这是一个很复杂的问题，，可以简单的理解为，因为找不到食物，而刺激大脑思考如何得到食物，大脑生成更多的神经突出，，，相比用剩下的营养去漫无目的的寻找食物，生成更多的神经突出，思考食物的出处，有目的的去寻找食物显然更加合算。</p><h3 id="关于武术"><a href="#关于武术" class="headerlink" title="关于武术"></a>关于武术</h3><p>前段时间有一个武术打假的徐晓东，其实我也是一样的，我并不相信武术这种东西，更相信搏击，真正的肉体搏击。<br>技巧只能少部分的提升你的攻击性，更多的是你的身高，体重，爆发，肌肉强度，甚至无关与智力。当你具有一定的攻击性的时候，说话就有了底气（气场这个东西很虚，但是确实存在，最主要的是前额叶高级神经中枢），你营养跟上后，就相当于有了一个大电池，可以源源不断的给大脑提供营养，此时你智力也会有更好的发展，所以不要觉得哪些可恶的人很笨，实际上是你占不到优势，很气愤才会觉得这个人很可恶。</p><h3 id="能量的吞金兽"><a href="#能量的吞金兽" class="headerlink" title="能量的吞金兽"></a>能量的吞金兽</h3><p>大脑消耗的能量和肌肉消耗的能量不是一个量级，几乎是十倍的差距，作为营养主要的消耗地方“大脑”得不到足够的营养能量来源而发育迟缓，表现出来就是当你集中精神去学习做事情的时候就会很恍惚，脑子不灵光，眼睛乱转，会本能的避开眼前正在集中精神思考的事情，会忽然的感觉大脑很难受，大脑发胀发热，或者忽然冷一下；这时候大脑疲劳，得不到足够的营养支撑，体内的血糖很低导致的，此时应该立即停止思考，深呼吸，眺望远方，补充个能量。</p><h3 id="沟通上的唯诺"><a href="#沟通上的唯诺" class="headerlink" title="沟通上的唯诺"></a>沟通上的唯诺</h3><p>当一个人身材瘦小的时候，总是很自卑的，得不到别人的认同，所以很少沟通，所以大脑的活跃量很少，神经突触就很少，表现出来就是不会说话，大家都会排斥，产生一个负向的循环。<br>别人一开口你都插不上嘴的情况你是否有经历过，即使别人讨论的是你擅长的领域，但你仍然说不过别人，你肚子里面有东西，但就是表达不出来，你很着急，但此时别人是一脸鄙视的。<br>所以当一个人营养跟上的时候，这个人应该是开朗的，健谈的，身材比例匀称的，肤色正常的，所以人不可貌相应当是错误的。</p><h3 id="奇怪的结论"><a href="#奇怪的结论" class="headerlink" title="奇怪的结论"></a>奇怪的结论</h3><p>那么得到一个结论就是，身体不是锻炼出来的，聪明不是学习出来的，而是吃出来的，这时候得到另一个结论就是，你身体的消化系统对你以后的发展起着至关重要的作用，所以吃就成了一个问题。怎么吃，怎么锻炼你的胃，怎么有效吸收，怎么使你的身体得到足够的养分，怎么调动你的身体积极吸收这些养分，，，，</p><h2 id="发育问题"><a href="#发育问题" class="headerlink" title="发育问题"></a>发育问题</h2><p><em>真是一个复杂的问题啊</em></p><h3 id="想吃什么吃什么"><a href="#想吃什么吃什么" class="headerlink" title="想吃什么吃什么"></a>想吃什么吃什么</h3><p>很多人会提起母乳的重要性，知道母乳是很重要的，但是为什么重要却不知道，母乳中含有婴幼儿的必须氨基酸，和人体中很多的益生菌种类，人体的健康就是被这些细菌操控着的，这些益生菌就像是有生命的酶一样，能够吸收转化很多物质。一些细菌甚至对你的身体是有微毒的，但是，只要你供的好就不会对你的身体造成伤害，当你吃的食物中长期缺乏一种食物的时候，一些细菌对这种食物又有特殊嗜好的时候，这个时候这些细菌就会抱怨，会恨你没给他吃这种食物，这时就会释放毒素刺激神经，让大脑知道“我”需要这种食物，这其实是有益的，这会平衡人体所需，</p><h3 id="维生，，素"><a href="#维生，，素" class="headerlink" title="维生，，素"></a>维生，，素</h3><p>很多人都知道维生素，但是维生素是什么又不知道，维生素分为脂溶性和水溶性，水溶性需求量大，无毒；脂溶性的需求量小，过量导致维生素中毒。维生素也是维他命是vitamin的谐音，为什么维生素重要呢？从字面上就可以理解了，维持生命，咳咳，，抽象理解就可以了；因为人体自身是无法自己合成的，所以被称为维生素，维生素的作用主要是用于合成体内特定的酶，作为酶的活性中心，或者特定酶的激活结构，人体就是一个巨大的化学工厂，每时每刻都进行着巨量的化学反应，化学反应的驱动就是酶，缺少了酶化学反应就受阻，生命活动就不能进行，，所以平衡饮食是非常重要的，，</p><h3 id="运动的好处"><a href="#运动的好处" class="headerlink" title="运动的好处"></a>运动的好处</h3><p>体型中把人体分为外胚型，中胚型，和内胚型，外胚型特征为高瘦，中胚型比较匀称，内胚型体型宽阔，</p><p>这样看来我应该使外胚型的体质，但是由于初中过度锻炼原因，身体营养没有跟上，瘦不说，身高也不足，甚至没有父亲的身高。外胚型体制基础代谢率比较高，就是由于基因的缘故，身体本身就处于一个代谢率高于平均水平的状态，所以营养大部分都拿来代谢掉了，只有少部分营养拿来构建身体，所以有吃不胖的瘦子，表面上哪些瘦子吃的比哪些胖子都多，但是就是不胖，都是拿来消耗了啊，</p><p>运动能加快身体循环，使身体加快代谢，这样你的身体和大脑都会更加的活跃，所需的营养也会更多，会促进食欲的增长与吸收。</p><p>大脑就像身体的cpu，身体就像ram运存，食物就像rom硬盘，当ram过小，即使cpu再强也会卡机，当ram向rom读取数据的时候如果读取的太慢也会感觉很卡，，，</p>]]></content>
      
      
      <categories>
          
          <category> 喝酒吃肉 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>vscode 远程开发</title>
      <link href="2020/02/22/fu-wu-qi/vscode-yuan-cheng-kai-fa/"/>
      <url>2020/02/22/fu-wu-qi/vscode-yuan-cheng-kai-fa/</url>
      
        <content type="html"><![CDATA[<blockquote class="blockquote-center">如何用vscode 进行线上开发,开发后即可部署。</blockquote><a id="more"></a><p>在插件中安装  Remote-SSH 远程工具<br><img src="https://s2.ax1x.com/2020/02/22/3QKJu4.png" alt="3QKJu4.png"></p><p>添加服务器<br><img src="https://s2.ax1x.com/2020/02/23/3lr4aR.png" alt="3lr4aR.png"></p><p>在顶部会出现一个需要输入ssh连接的命令，根据提示输入你远端的账户和地址<br><img src="https://s2.ax1x.com/2020/02/22/3QKeBj.png" alt="3QKeBj.png"></p><p>或者按F1，输入 Remote-SSH 选择 Connect to Host - Configure SSH Hosts：<br><img src="https://s2.ax1x.com/2020/02/22/3QMKqH.png" alt="3QMKqH.png"></p><p>直接编辑ssh config 文件<br><img src="https://s2.ax1x.com/2020/02/22/3QMgQU.png" alt="3QMgQU.png"><br><img src="https://s2.ax1x.com/2020/02/22/3QMoJx.png" alt="3QMoJx.png"></p><p>依次填写服务器的别名、主机名（ IP 或者域名）、用户名，保存。<br><img src="https://s2.ax1x.com/2020/02/22/3QQPl8.png" alt="3QQPl8.png"></p><p>然后就可以在左端面板上看见你添加的ssh 远端服务器，右击选择连接就可以了，中间vscode出现防火墙提示请通过。</p><p>如果出现以下问题，可能是你的ssh config文件的路径有问题，因为windows的路径切换用的是”\“,而linux 用的”/“,在vscode中配置的时候会用”/“ ,所以在windows中可能会出现以下问题，<br><img src="https://s2.ax1x.com/2020/02/22/3QlLad.png" alt="3QlLad.png"></p><p>这时候应该手动设置ssh 配置文件路径<br>在设置中搜索<code>remote ssh config file</code></p><p>ssh配置文件一般是在你的用户目录下，为隐藏文件，没有的话就自己新建一个<br><img src="https://s2.ax1x.com/2020/02/22/3QBIDs.png" alt="3QBIDs.png"></p><p>退出保存后就可以登录服务器了，这时候是用的密码的方式登录，连接后会在编辑器顶部出现输入框，输入密码连接。</p><p>进去后就是熟悉的模式，熟悉的vscode的味道，但是连接的终端服务器却是云服务器。</p><p>此后你也可以配置密匙对进行安全连接，后期更。</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>js初级算法合集</title>
      <link href="2020/02/15/suan-fa/js-suan-fa/js-chu-ji-suan-fa-ji-he/"/>
      <url>2020/02/15/suan-fa/js-suan-fa/js-chu-ji-suan-fa-ji-he/</url>
      
        <content type="html"><![CDATA[<blockquote class="blockquote-center">js初级算法合集</blockquote><a id="more"></a><h2 id="一、翻转字符串"><a href="#一、翻转字符串" class="headerlink" title="一、翻转字符串"></a>一、翻转字符串</h2><p>自己写出来的丑陋代码</p><pre><code class="js">function reverseString(str) &#123;    var turn = &#39;&#39;;for (var i = str.length-1; i &gt; -1; i--) &#123;    turn = turn + str[i];&#125;return turn;&#125;reverseString(&quot;hello&quot;);</code></pre><p>输出为：</p><pre><code>olleh</code></pre><h2 id="二、阶乘算法"><a href="#二、阶乘算法" class="headerlink" title="二、阶乘算法"></a>二、阶乘算法</h2><pre><code class="js">function factorialize(num) &#123;    var sum =1;    for (var i = 1; i &lt;= num; i++) &#123;        sum = sum * i;    &#125;return sum;&#125;factorialize(5);</code></pre><p>输出为：</p><pre><code>120</code></pre><h2 id="三、判断文字是否为回文"><a href="#三、判断文字是否为回文" class="headerlink" title="三、判断文字是否为回文"></a>三、判断文字是否为回文</h2><pre><code class="js">function palindrome(str) &#123;// 删除文字中的空格，符号，留下字母var newstr = str.replace(/[^0-9a-z]/gi, &quot;&quot;);// 把大写的字母转换成小写字符newstr = newstr.toLowerCase();// 把原有的字符串回文for (var i = 0, j = newstr.length - 1; i &lt; j; i++, j--) &#123;     if (newstr.charAt(i) !== newstr.charAt(j))     &#123;         return false; //逐个字符比较，不匹配返回false    &#125; &#125; return true;&#125;palindrome(&quot;eye&quot;);</code></pre><p>输出为：</p><pre><code>true</code></pre><h2 id="四、寻找最长的单词算法"><a href="#四、寻找最长的单词算法" class="headerlink" title="四、寻找最长的单词算法"></a>四、寻找最长的单词算法</h2><pre><code class="js">function findLongestWord(str) &#123;    var str_list = str.split(&quot; &quot;); //根据空格进行单词分割，放入列表    var word_lenght = 0;    for (var i=1; i &lt; str_list.length; i++)&#123;          if (str_list[i].length &gt; word_lenght) &#123;            word_lenght = str_list[i].length; //遇见长度大的赋值        &#125;    &#125;    return word_lenght;&#125;</code></pre><h2 id="五、设置首字母大写算法"><a href="#五、设置首字母大写算法" class="headerlink" title="五、设置首字母大写算法"></a>五、设置首字母大写算法</h2><pre><code class="js">function titleCase(str) &#123;  var newStr = str.split(&quot; &quot;);  for(var i=0; i&lt;newStr.length; i++)&#123;    newStr[i] = newStr[i].slice(0, 1).toUpperCase() + newStr[i].slice(1).toLowerCase(); //使用切片和转化大小写函数实现  &#125;  return newStr.join(&quot; &quot;);  //使列表用空格生成句子&#125;titleCase(&quot;I&#39;m a little tea pot&quot;);</code></pre><p>结果为：</p><pre><code>I&#39;m A Little Tea Pot</code></pre><h2 id="六、寻找数组中的最大值"><a href="#六、寻找数组中的最大值" class="headerlink" title="六、寻找数组中的最大值"></a>六、寻找数组中的最大值</h2><pre><code class="js">function largestOfFour(arr) &#123;    var arr_list = [];    for (var i=0; i&lt;arr.length; i++)&#123;        arr_list[i] = 0;        for (var u=0; u&lt;arr[i].length; u++)&#123;            var max_num=0;            if (arr[i][u]&gt;arr_list[i])&#123;                arr_list[i] = arr[i][u]        &#125;    &#125;&#125;return arr_list;&#125;largestOfFour([[4, 5, 1, 3], [13, 27, 18, 26], [32, 35, 37, 39], [1000, 1001, 857, 1]]);</code></pre><p>结果为：</p><pre><code>[5,27,39,1001]</code></pre><h2 id="七、确认末尾字符"><a href="#七、确认末尾字符" class="headerlink" title="七、确认末尾字符"></a>七、确认末尾字符</h2><pre><code class="js">function confirmEnding(str, target) &#123;//截取与判断字符相同的字符var tar_length = target.length;var str_last = str.substr(-tar_length)//与判断字符比较if ( target == str_last )&#123;    return true;&#125;return false;&#125;// return target==str_last;confirmEnding(&quot;Bastian&quot;, &quot;n&quot;);</code></pre><h2 id="八、重复操作算法"><a href="#八、重复操作算法" class="headerlink" title="八、重复操作算法"></a>八、重复操作算法</h2><pre><code class="js">function repeat(str, num) &#123;    if(num &gt; 0)    &#123;        var newStr = &quot;&quot;;        for(var i = 0; i &lt; num; i++)&#123;            newStr = newStr + str;        &#125;        return newStr;    &#125;    else return &quot;&quot;;&#125;repeat(&quot;abc&quot;, 3);</code></pre><h2 id="九、字符串截取算法"><a href="#九、字符串截取算法" class="headerlink" title="九、字符串截取算法"></a>九、字符串截取算法</h2><p>显示约定多的字符，多余的字符用…表示</p><pre><code class="js">function truncate(str, num) &#123;if (num &gt; 3)&#123;    if (str.length &gt; num)&#123;        str = str.slice(0, num-3) + &quot;...&quot;    &#125;&#125;else&#123;      str = str.slice(0,num) + &quot;...&quot;  &#125;return str;&#125;truncate(&quot;A-tisket a-tasket A green and yellow basket&quot;, 11);</code></pre><h2 id="十、数组分割算法"><a href="#十、数组分割算法" class="headerlink" title="十、数组分割算法"></a>十、数组分割算法</h2><p>基本上就是字符串分割算法，这个还是不太合理，需要更加合理的底层算法。</p><pre><code class="js">function chunk(arr,size)&#123;           var chunk=[];           while(arr.length&gt;0)&#123;                   chunk.push(arr.splice(0,size));       &#125;return chunk;&#125;chunk([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;], 2);</code></pre><h2 id="十一、数组截断算法"><a href="#十一、数组截断算法" class="headerlink" title="十一、数组截断算法"></a>十一、数组截断算法</h2><p>第一个参数从第二个参数开始截断</p><pre><code class="js">function slasher(arr, howMany) &#123;    if (howMany &gt; arr.length) &#123;        arr = [];    &#125; else &#123;        arr = arr.splice(howMany)    &#125;    return arr;&#125;slasher([1, 2, 3], 1);</code></pre><h2 id="十二、数组查询算法"><a href="#十二、数组查询算法" class="headerlink" title="十二、数组查询算法"></a>十二、数组查询算法</h2><p>[“hello”, “Hello”]应该返回true，在忽略大小写的情况下，第二个字符串的所有字符都可以在第一个字符串找到。</p><p>[“hello”, “hey”]应该返回false，因为字符串”hello”并不包含字符”y”。</p><pre><code class="js">function mutation(arr) &#123;    var str1 = arr[0].toLowerCase();    var str2 = arr[1].toLowerCase();    var strArr = str2.split(&quot;&quot;);    for (var i = 0; i &lt; strArr.length; i++) &#123;        var pos = str1.indexOf(strArr[i]);  ////indexOf用于从头到尾检测字符串是否含有字串，它对大小写敏感        if (pos === -1) &#123;            return false;        &#125;    &#125;    return true;&#125;mutation([&quot;hello&quot;, &quot;hey&quot;]);</code></pre><h2 id="十三、删除数组中特定值算法"><a href="#十三、删除数组中特定值算法" class="headerlink" title="十三、删除数组中特定值算法"></a>十三、删除数组中特定值算法</h2><p>删除数组中的所有的假值。<br>在JavaScript中，假值有false、null、0、””、undefined 和 NaN。</p><pre><code class="js">function bouncer(arr) &#123;var t = [];for (var i = 0; i &lt; arr.length; i++) &#123;    if (Boolean(arr[i])) &#123;  //直接转换成布尔值if来判断。       t.push(arr[i]);    &#125;&#125;return t;&#125;</code></pre><h2 id="十四、去除数组中任意多个值算法"><a href="#十四、去除数组中任意多个值算法" class="headerlink" title="十四、去除数组中任意多个值算法"></a>十四、去除数组中任意多个值算法</h2><p>实现一个 destroyer 函数，第一个参数是初始数组，后跟一个或多个参数。从初始数组中删除与这些参数具有相同值的所有元素。</p><p>destroyer([1, 2, 3, 1, 2, 3], 2, 3) 应该返回 [1, 1].</p><p>destroyer([1, 2, 3, 5, 1, 2, 3], 2, 3) 应该返回 [1, 5, 1].</p><p>这个暂时不太理解，摘自[<a href="https://blog.csdn.net/qq_42044073/article/details/82491676]">https://blog.csdn.net/qq_42044073/article/details/82491676]</a></p><pre><code class="js">function destroyer(arr) &#123;    return [].slice.call(arguments).reduce(function (prev, next) &#123;        return prev.filter(e =&gt; e !== next);    &#125;);&#125;destroyer([1, 2, 3, 1, 2, 3], 2, 3);</code></pre><h2 id="十五、数组排序并插入值算法"><a href="#十五、数组排序并插入值算法" class="headerlink" title="十五、数组排序并插入值算法"></a>十五、数组排序并插入值算法</h2><pre><code class="js">function where(arr, num) &#123;arr.sort(function(a,b)&#123;   //首先进行数组的排序   return a - b; &#125;)    for(var i = 0; i &lt; arr.length; i ++)&#123;  //遍历数字找到对应的索引        if (arr[i] &gt;= num)&#123;              return i;        &#125;else if (num &gt; arr[arr.length-1])&#123;  //如果没有适合的插入点，直接插入到最后            return arr.length;        &#125;    &#125;&#125;where([2, 5, 10], 15)</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> js初级算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>不管怎样</title>
      <link href="2019/12/24/he-jiu-chi-rou/bu-guan-zen-yang/"/>
      <url>2019/12/24/he-jiu-chi-rou/bu-guan-zen-yang/</url>
      
        <content type="html"><![CDATA[<blockquote class="blockquote-center">———— 特蕾莎修女</blockquote><a id="more"></a><p>这是我在看陈果《善与德》视频的时候摘抄的，其中我也不知道为什么我会觉得善良很重要，也许是奶奶从小教导我要从善，要做一个好人，不求大富大贵的思想吧。</p><p>为什么好人不作为？<br>我记得在上高中的时候，一天中午往常一样去上课，路过滨河路的时候看见有一位老人，走路的时候明显就是不对的，他是杵着一个拐杖，但是他却使劲的，努力的想把重量分单在拐杖上，走两步停两步。我看着背影就觉得不太对，就放慢了脚步跟在了后面，果不其然那老人，就在我前面几米的地方，头向着天上仰去，两腿就软了下来，双手使劲的拽着拐杖，倒了下来。想都没想，疾步上去就揽住了那位老人，由于太重重心不稳，我也一起摔倒在地，但是好在老人没有磕在地面，我也没有受伤，我扶起了老人，此时老人神智似乎还有些模糊，我猜估计是低血糖，就没有让老人起来，让他坐着，此时周围的人就围了过来，但，，，也就只是围了过来，没有一个人上来帮忙，我也犹豫了下，似乎我不应该摊上这事啊，我还要上课，难道我还要送老人去医院？我一激灵，环顾了下四周，发现了个似乎很有钱的胖子，“ 哈哈，就是你了，你不上来，我让你上来 ”，我就对着这个中年人讲“ 叔叔，你可以帮个忙叫下120吗？我还要上课，能帮忙把这位老人送去医院不？” 说着我起身就要离开了，同时在我的请求下也上来了些人扶着老人，给老人遮阳（那时是中午，吃了饭去学校的途中），然后我就离开了，至于后来老人怎么样了我就不太清楚了，这是我也没跟其他人提起过，每天也是照常上课。<br>我在看他们眼神的时候并不是不想上前，而都是在顾虑，，，</p><p>为什么想起了这件事，我并没有拿这件事来吹嘘自己，但是拿现在的我来说，如果遇到同样的事情，我依然会上前，那些人不动，我就让他们动，那些人不行善，我就让他们行善，即使他们是不情愿的，但是你帮他们做了件好事。</p><p>其中我觉得很珍贵的一句话就是：知行合一，身心一致，以身载道，践行真理。</p><p>以下摘自特蕾莎修女的名言：</p><p>People are often unreasonable， irrational， and self-centered.</p><p>Forgive them anyway.</p><p>If your are kind, people may accuse you of selfishness, ulterior motives.</p><p>Be kind anyway.</p><p>If you are successful, you will win some unfaithful friends and some genuine enemies.</p><p>Succeed anyway.</p><p>If you are honest and sincere, people may decieve you.</p><p>Be honest and sincere anyway.</p><p>What you spend years creating , others could destroy overnight.</p><p>Create anyway</p><p>If you find serenity and happiness, some may be jealous.</p><p>Be happy anyway.</p><p>The good you do today, will often be forgotten.</p><p>Do good anyway.</p><p>Give the best you have, and it will never be enough.</p><p>Give your best anyway.</p><p>In the final analysis, it is between you and God. It is never between you and them anyway.</p><h3 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h3><p>人们经常是不讲道理的，没有逻辑的，和自我为中心的。</p><p>不管怎样，你要原谅他们。</p><p>即使你是友善的，人们可能时还是会说你自私和动机不良的。</p><p>不管怎样，还是要友善。</p><p>当你有一天功成名就，你会有很多虚假的朋友和一些真实的敌人。</p><p>不管怎样，你要取得成功。</p><p>即使你是诚实的和直率的，人们可能还是会欺骗你。</p><p>不管怎样，还是要诚实，还是要率直。</p><p>你多年来营造的东西，有人在一夜之间将它摧毁。</p><p>不管怎样，还是要去营造。</p><p>如果有一天，你找到了平静和幸福，他们可能会忌妒你。</p><p>不管怎样，还是要快乐。</p><p>你今天做的善事，人们往往明天就会忘记。</p><p>不管怎样，你还是要做善事。</p><p>即使你把最好的东西都给了这个世界，也许这些东西永远都还不够。</p><p>不管怎样，把你最好的东西给这个世界。</p><p>所以说，这只是关于你和上帝之间的事，绝对不是关于其他人的事。</p>]]></content>
      
      
      <categories>
          
          <category> 喝酒吃肉 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>寻找最长单词算法</title>
      <link href="2019/12/20/suan-fa/js-suan-fa/xun-zhao-zui-chang-dan-ci-suan-fa/"/>
      <url>2019/12/20/suan-fa/js-suan-fa/xun-zhao-zui-chang-dan-ci-suan-fa/</url>
      
        <content type="html"><![CDATA[<blockquote class="blockquote-center">用split函数把字符串分割成列表，然后判断列表中字符串的长度，进行比较。</blockquote><a id="more"></a><pre><code class="js">function findLongestWord(str) &#123;    var str_list = str.split(&quot; &quot;);    var word_lenght = 0;    for (var i=1; i &lt; str_list.length; i++)&#123;        if (str_list[i].length &gt; word_lenght) &#123;            word_lenght = str_list[i].length;        &#125;    &#125;    return word_lenght;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> js初级算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>判断字符是否为回文</title>
      <link href="2019/12/20/suan-fa/js-suan-fa/pan-duan-zi-fu-shi-fou-wei-hui-wen/"/>
      <url>2019/12/20/suan-fa/js-suan-fa/pan-duan-zi-fu-shi-fou-wei-hui-wen/</url>
      
        <content type="html"><![CDATA[<blockquote class="blockquote-center">palindrome(回文)是指一个字符串忽略标点符号、大小写和空格，正着读和反着读一模一样。</blockquote><a id="more"></a><p>其中涉及到正则表达式，，，</p><pre><code class="js">function palindrome(str) &#123;// 删除文字中的空格，符号，留下字母var newstr = str.replace(/[^0-9a-z]/gi, &quot;&quot;);// 把大写的字母转换成小写字符newstr = newstr.toLowerCase();// 把原有的字符串回文for (var i = 0, j = newstr.length - 1; i &lt; j; i++, j--) &#123;     if (newstr.charAt(i) !== newstr.charAt(j))     &#123;         return false; //逐个字符比较，不匹配返回false    &#125; &#125; return true;&#125;palindrome(&quot;eye&quot;);</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> js初级算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>nodejs异步回调的理解</title>
      <link href="2019/12/20/nodejs/nodejs-yi-bu-hui-diao-de-li-jie/"/>
      <url>2019/12/20/nodejs/nodejs-yi-bu-hui-diao-de-li-jie/</url>
      
        <content type="html"><![CDATA[<blockquote class="blockquote-center">异步编程的体现就是回调。</blockquote><a id="more"></a><p>所谓异步编程体现的就是回调。</p><p>例如，我们可以一边读取文件，一边执行其他命令，在文件读取完成后，我们将文件内容作为回调函数的参数返回。这样在执行代码时就没有阻塞或等待文件 I/O 操作。</p><p>同步操作一般是先读取文件，读取完成后给到一个变量，然后继续执行程序，程序执行到需要这个文件数据的时候填入变量，这样一步一步的操作，相对于异步同时读取文件的时候就执行其他命令，节约了读取文件数据的时间，这样大大提高了nodejs的性能，在处理高并发请求的时候有着显著的性能提升。</p><h3 id="同步阻塞代码实例"><a href="#同步阻塞代码实例" class="headerlink" title="同步阻塞代码实例"></a>同步阻塞代码实例</h3><p>创建一个input.txt文件,写入“hello world”</p><pre><code>var fs = require(&quot;fs&quot;);var data = fs.readFileSync(&#39;input.txt&#39;);console.log(data.toString());console.log(&quot;程序执行结束!&quot;);</code></pre><p>输出：</p><pre><code>$ node main.jshello world程序执行结束!</code></pre><h3 id="异步非阻塞代码实例"><a href="#异步非阻塞代码实例" class="headerlink" title="异步非阻塞代码实例"></a>异步非阻塞代码实例</h3><p>创建一个input.txt文件,写入“hello world”</p><pre><code>var fs = require(&quot;fs&quot;);fs.readFile(&#39;input.txt&#39;, function (err, data) &#123;    if (err) return console.error(err);    console.log(data.toString());&#125;);console.log(&quot;程序执行结束!&quot;);</code></pre><p>输出：</p><pre><code>$ node main.js程序执行结束!hello world</code></pre><p><em>代码来自菜鸟教程</em></p>]]></content>
      
      
      <categories>
          
          <category> nodejs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 异步回调 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>colemak dvorak norman 键盘布局</title>
      <link href="2019/12/18/linux/colemak-dvorak-norman-jian-pan-bu-ju/"/>
      <url>2019/12/18/linux/colemak-dvorak-norman-jian-pan-bu-ju/</url>
      
        <content type="html"><![CDATA[<blockquote class="blockquote-center">以前看了一片文章，说现在的qwerty键盘布局很低效，我也只是看了下。后来在谈论键盘布局的时候和室友起了争执，室友说现在的键盘布局是根据字母使用频率来排布的，“很科学”，我当时很惊奇！！还没怎么争论还口，室友就又活在了自己的世界里，唉，实在争不过啊！！这个事件后我对这个键盘布局产生了一丝兴趣。下面这篇文章来介绍下主要的几个键盘布局。</blockquote><a id="more"></a><p><strong>我参照了现在比较热门的键盘布局，有colemak layout; Dvorak layout; norman layout;</strong></p><h3 id="qwerty-英文下的热力图"><a href="#qwerty-英文下的热力图" class="headerlink" title="qwerty 英文下的热力图"></a>qwerty 英文下的热力图</h3><p><img src="https://s2.ax1x.com/2019/12/19/Qq31pT.png" alt="Qq31pT.png"></p><h3 id="qwerty中文下的热力图"><a href="#qwerty中文下的热力图" class="headerlink" title="qwerty中文下的热力图"></a>qwerty中文下的热力图</h3><p><img src="https://s2.ax1x.com/2019/12/18/QHizLQ.png" alt="QHizLQ.png"></p><p>可以看出不只是英文输入，中文拼音输入时也是一样的，使用频率高的几个键都跑偏，说qwerty真的是效率杀手一点也不为过，，，</p><h2 id="dvorak-键盘布局"><a href="#dvorak-键盘布局" class="headerlink" title="dvorak 键盘布局"></a>dvorak 键盘布局</h2><p>这个布局丑的一批，似乎这种布局在以前很流行，但是现在基本没有多少人用了，</p><!-- ![Q7xFTf.png](https://s2.ax1x.com/2019/12/18/Q7xFTf.png) --><!-- ![QHNkfx.png](https://s2.ax1x.com/2019/12/18/QHNkfx.png) --><h3 id="在英文下的热力图"><a href="#在英文下的热力图" class="headerlink" title="在英文下的热力图"></a>在英文下的热力图</h3><p><img src="https://s2.ax1x.com/2019/12/19/Qq8D5q.png" alt="Qq8D5q.png"></p><h3 id="在中文拼音下的热力图"><a href="#在中文拼音下的热力图" class="headerlink" title="在中文拼音下的热力图"></a>在中文拼音下的热力图</h3><p><img src="https://s2.ax1x.com/2019/12/19/Qq8hZ9.png" alt="Qq8hZ9.png"></p><p>这种键盘的主要弊端就是<code>z,x,c,v</code>这几个键位都偏到了不知道的地方，在windows操作系统中非常的不合适，但是在linux系统中可以设置快捷键来改变。</p><h2 id="最后说下-colemak-layout"><a href="#最后说下-colemak-layout" class="headerlink" title="最后说下 colemak layout"></a>最后说下 colemak layout</h2><!-- ![Q7jzq0.png](https://s2.ax1x.com/2019/12/18/Q7jzq0.png) --><p>我个人是比较喜欢这个键盘布局的，因为这个键盘布局保留了<code>z,x,c,v</code>这几个键位，这几个键位在win10中的作用不用多说，“撤销”，“剪切”，“复制”，“粘贴”。其次在使用中把使用频率最高的字母放在了中间的，使得手指不用频繁的离开原来的位置而打字。</p><h3 id="下面是英文的使用热力图"><a href="#下面是英文的使用热力图" class="headerlink" title="下面是英文的使用热力图"></a><strong>下面是英文的使用热力图</strong></h3><!-- ![Q7zc5T.png](https://s2.ax1x.com/2019/12/18/Q7zc5T.png) --><p><img src="https://s2.ax1x.com/2019/12/18/QHUFbQ.png" alt="QHUFbQ.png"></p><p>其中使用英文的时候基本所有的使用频率高的字母都是排列在了中间的一排位置。这样在使用英文的时候可以极大的提高打字的速度。</p><h3 id="这个是我把中文转换为拼音后的热力图"><a href="#这个是我把中文转换为拼音后的热力图" class="headerlink" title="这个是我把中文转换为拼音后的热力图"></a><strong>这个是我把中文转换为拼音后的热力图</strong></h3><!-- ![Q7zxsA.png](https://s2.ax1x.com/2019/12/18/Q7zxsA.png) --><p><img src="https://s2.ax1x.com/2019/12/18/QHU8a9.png" alt="QHU8a9.png"><br>我们在输入中文的时候使用频率最高的是“<code>i</code>”这个键，可以看到，这个键盘布局在输入中文的时候相比qwerty键盘布局是要高效很多的，其中使用频率相对较高的<code>g</code>和<code>z</code>是没有在中间的位置，还有就是右手的负担有点过大。</p><h2 id="再介绍下这个-norman-键盘布局"><a href="#再介绍下这个-norman-键盘布局" class="headerlink" title="再介绍下这个 norman 键盘布局"></a>再介绍下这个 norman 键盘布局</h2><h3 id="下面是英文输入时的热力图"><a href="#下面是英文输入时的热力图" class="headerlink" title="下面是英文输入时的热力图"></a>下面是英文输入时的热力图</h3><!-- ![QH9RG8.png](https://s2.ax1x.com/2019/12/18/QH9RG8.png) --><p><img src="https://s2.ax1x.com/2019/12/18/QHNqDe.png" alt="QHNqDe.png"><br>不用多说，看着就挺美的</p><h3 id="这个是输入中文拼音时的热力图"><a href="#这个是输入中文拼音时的热力图" class="headerlink" title="这个是输入中文拼音时的热力图"></a>这个是输入中文拼音时的热力图</h3><!-- ![QHp07q.png](https://s2.ax1x.com/2019/12/18/QHp07q.png) --><p><img src="https://s2.ax1x.com/2019/12/18/QHN6jU.png" alt="QHN6jU.png">  </p><p>这样的布局我觉得是比较合适的，相比于<code>colemak</code>他把<code>e</code>键移到了左手，<code>i</code>键挪到了右手中指，同时把<code>g</code>键从一个比较偏的位置挪到了中间一排，使得右手的负担大大减小，左右手可以协同输入。</p><p>最后说下，我先开始是没有了解到这个<code>normen</code> 布局的，我先开始上手的是<code>colemak</code> 键盘布局，用了半个多月，在输入英文的时候感觉这个布局是比<code>qwerty</code>键盘明显高效很多的，有一种很奇怪的就把子打完了的感觉。在输入中文的时候个人感觉不是很顺滑，右手的使用频率很高，而且左右手不是在协同操作，总是感觉一个手打了很多的字。其中热力图就显示出来了，右手的使用要明显高于左手的。使用了半个多月后我还是换回了<code>qwerty</code>键盘布局，主要原因还是觉得我如果用其他人电脑的时候没法使用键盘。</p><p>在学习<code>colemak</code>键盘布局的时候我也花费了很多的时间去适应，大概花费了一星期左右大概达到了原有的水平，想学习的小朋友还是要斟酌斟酌了，毕竟是改变原有的操作习惯，而且还是潜意识的操作习惯，其中的学习代价是很高的，学完后，还有弊端就是，大家都跟你不一样，别人没法用你的电脑，你也基本也没法操作别人的电脑，如果你换回原有的键盘布局也有一到两天的适应时间。</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 键盘布局 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js实现翻转字符串</title>
      <link href="2019/12/10/suan-fa/js-suan-fa/js-shi-xian-fan-zhuan-zi-fu-chuan-suan-fa/"/>
      <url>2019/12/10/suan-fa/js-suan-fa/js-shi-xian-fan-zhuan-zi-fu-chuan-suan-fa/</url>
      
        <content type="html"><![CDATA[<blockquote class="blockquote-center">通过对字符列表的for循环倒着添加到一个字符列表，即字符串。</blockquote><a id="more"></a><h3 id="翻转字符串"><a href="#翻转字符串" class="headerlink" title="翻转字符串"></a>翻转字符串</h3><p>自己写出来的丑陋代码</p><pre><code class="js">function reverseString(str) &#123;    var rstr = &#39;&#39;;for (var i = str.length-1; i &gt; -1; i--) &#123;    rstr = rstr + str[i];&#125;return rstr;&#125;reverseString(&quot;hello&quot;);</code></pre><p>输出结果为olleh</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> js初级算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>云端ide配置anaconda3环境</title>
      <link href="2019/12/08/yun-ide/yun-duan-ide-pei-zhi-anaconda3-huan-jing/"/>
      <url>2019/12/08/yun-ide/yun-duan-ide-pei-zhi-anaconda3-huan-jing/</url>
      
        <content type="html"><![CDATA[<blockquote class="blockquote-center">使用Cloud studio 配置anaconda3环境的时候要设置.zshrc文件配置环境变量。</blockquote><a id="more"></a><h2 id="什么是Cloud-studio"><a href="#什么是Cloud-studio" class="headerlink" title="什么是Cloud studio"></a>什么是Cloud studio</h2><p>不用多说给出官方链接(<a href="https://studio.dev.tencent.com/">https://studio.dev.tencent.com/</a>)</p><p>为什么我开始使用Cloud studio ,因为这个webIDE提供了完整的Linux环境，其次是提供了webIDE协同开发这种模式，这个IDE应该就可以看作是云端的一个vscode.</p><p><strong>弊端</strong><br>每个用户每日只可以使用两小时。</p><h2 id="注册Cloud-studio"><a href="#注册Cloud-studio" class="headerlink" title="注册Cloud studio"></a>注册Cloud studio</h2><p>点击上方链接注册coding账号<br><img src="https://s2.ax1x.com/2019/12/08/QaFbYd.png" alt="QaFbYd.png"><br><img src="https://s2.ax1x.com/2019/12/08/QaFXlt.png" alt="QaFXlt.png"><br>完成注册后就可以进入编辑工具了</p><p><a href="https://imgse.com/i/Qakn7F"><img src="https://s2.ax1x.com/2019/12/08/Qakn7F.md.png" alt="Qakn7F.md.png"></a></p><p>点击跳过</p><p><strong>按照提示新建项目或导入项目,或者直接跳过</strong><br><img src="https://s2.ax1x.com/2019/12/08/Qak311.png" alt="Qak311.png"></p><p><strong>在右上方，点击code的图标，就可以进入Cloud studio</strong><br><img src="https://s2.ax1x.com/2019/12/08/QakN7D.png" alt="QakN7D.png"></p><p><strong>创建一个环境，仓库可以选空，如果有可以填上你的仓库地址</strong><br><img src="https://s2.ax1x.com/2019/12/08/QakgHS.png" alt="QakgHS.png"></p><p>基本就是熟悉的vscode的界面了，然后选择终端更新apt</p><blockquote><p>apt update<br>apt upgrade</p></blockquote><p>安装wget 和vim 并下载anaconda3</p><blockquote><p>apt install -y wget vim<br>wget <a href="https://repo.anaconda.com/archive/Anaconda3-2019.10-Linux-x86_64.sh">https://repo.anaconda.com/archive/Anaconda3-2019.10-Linux-x86_64.sh</a></p></blockquote><p>在下载的anaconda目录下</p><blockquote><p>zsh Anaconda3-2019.10-Linux-x86_64.sh</p></blockquote><p>然后同意协议<code>yes</code>，是否使用使用conda做为默认环境(这里看你喜好，我是选的yes,默认是no)</p><p>不过可以通过<code>conda config --set auto_activate_base false/true</code>进行更改</p><p>然后进入<code>.bashrc</code>跳到最后复制conda的环境配置变量到<code>.zshrc</code>文件中</p><blockquote><p>vim ~/.bashrc<br><img src="https://s2.ax1x.com/2019/12/08/QaEbY4.png" alt="QaEbY4.png"></p></blockquote><p>进入.zshrc文件中粘贴到末尾保存</p><blockquote><p>vim ~/.zshrc</p></blockquote><p>注意这是在.zshrc配置文件中<br><img src="https://s2.ax1x.com/2019/12/08/QaEj61.png" alt="QaEj61.png"></p><p>使用.zshrc配置文件作为源</p><blockquote><p>source ~/.zshrc</p></blockquote><p>这时候发现conda命令就可以使用了 python也是使用的anaconda3的环境</p><p>===</p><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a><em>后记</em></h3><h4 id="关于bash-和-zsh-两种shell"><a href="#关于bash-和-zsh-两种shell" class="headerlink" title="关于bash 和 zsh 两种shell"></a>关于bash 和 zsh 两种shell</h4><p>一般Linux默认使用的是<code>bash</code>这种shell</p><p>Zsh具有以下主要功能：</p><ul><li>开箱即用、可编程的命令行补全功能可以帮助用户输入各种参数以及选项。</li><li>在用户启动的所有shell中共享命令历史。</li><li>通过扩展的文件通配符，可以不利用外部命令达到find命令一般展开文件名。</li><li>改进的变量与数组处理。</li><li>在缓冲区中编辑多行命令。</li><li>多种兼容模式，例如使用/bin/sh运行时可以伪装成Bourne shell。</li><li>可以定制呈现形式的提示符；包括在屏幕右端显示信息，并在键入长命令时自动隐藏。</li><li>可加载的模块，提供其他各种支持：完整的TCP与Unix域套接字控制，FTP客户端与扩充过的数- 学函数。</li><li>完全可定制化。</li></ul><p>切换两种<code>shell</code>命令</p><blockquote><p>chsh -s /bin/bash</p></blockquote><blockquote><p>chsh -s /bin/zsh</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 云IDE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 云IDE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客的误区</title>
      <link href="2019/12/07/he-jiu-chi-rou/bo-ke-de-wu-qu/"/>
      <url>2019/12/07/he-jiu-chi-rou/bo-ke-de-wu-qu/</url>
      
        <content type="html"><![CDATA[<blockquote class="blockquote-center">关于写博客的一些误区</blockquote><a id="more"></a><h2 id="敢于写，敢于尝试，敢于分享"><a href="#敢于写，敢于尝试，敢于分享" class="headerlink" title="敢于写，敢于尝试，敢于分享"></a><strong>敢于写，敢于尝试，敢于分享</strong></h2><p>以前总觉得写博客一定是要写的很正式，写的有技术含量，但我接触的都是写没有技术含量的东西，所以一直都没有怎么写博客。现在想起来，真是犯了一个大错，以前学东西总是学什么忘什么，自己也不以为然，到现在猛然醒悟，学习是一个学与习的过程，学完东西是要去用的，用的时候才会加深映像。</p><h2 id="人生应留下些东西，走过的路应有痕迹"><a href="#人生应留下些东西，走过的路应有痕迹" class="headerlink" title="人生应留下些东西，走过的路应有痕迹"></a>人生应留下些东西，走过的路应有痕迹</h2><p>我想我的博客平台应该是一个人身宝库，不管是踩坑、感悟、还是code，我都应该去记录，毕竟应该留下些什么东西。</p><h2 id="总盯着过去你会瞎掉一只眼，忘却过去会双目失明。"><a href="#总盯着过去你会瞎掉一只眼，忘却过去会双目失明。" class="headerlink" title="总盯着过去你会瞎掉一只眼，忘却过去会双目失明。"></a>总盯着过去你会瞎掉一只眼，忘却过去会双目失明。</h2><p>我讨厌过去，因为在我小时候的经历，因为一些阴影总会想去忘却这些事情，也许是因为逃避，我总是想要忘记过去的一些事情，不愿去提及，但是想着忘记的时候又映像更加深刻，久而久之成了疾。</p><h2 id="当下即最好"><a href="#当下即最好" class="headerlink" title="当下即最好"></a>当下即最好</h2><p>在《围城》中说到，城外的人想进去，城里的人想出来，虽是讲婚姻，但是放到大的环境中也是如此的；这和《蓝，另一种蓝》中的思想是差不多的，即当下即最好，我们要做的就是让当下变得更好。</p><h2 id="傻是一种福气"><a href="#傻是一种福气" class="headerlink" title="傻是一种福气"></a>傻是一种福气</h2><p><em>坚持最重要，保留一颗敬畏之心</em></p>]]></content>
      
      
      <categories>
          
          <category> 喝酒吃肉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 误区 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二、矩阵链乘法</title>
      <link href="2019/12/03/suan-fa/python-suan-fa/er-ju-zhen-lian-cheng-fa/"/>
      <url>2019/12/03/suan-fa/python-suan-fa/er-ju-zhen-lian-cheng-fa/</url>
      
        <content type="html"><![CDATA[<blockquote class="blockquote-center">矩阵乘法是一个满足结合律的运算。矩阵A、B、C来说，(AB)C 与 A(BC) 是等价的，但是计算机不可以。</blockquote><a id="more"></a><h2 id="矩阵链算法"><a href="#矩阵链算法" class="headerlink" title="矩阵链算法"></a>矩阵链算法</h2><p>矩阵乘法是一个满足结合律的运算。显然，对于矩阵A、B、C来说，(AB)C 与 A(BC) 是等价的，我们可以根据自己的心情选择任意的运算顺序，总之，结果都是一样的。</p><p>糟糕的是，对计算机来说可不是这么回事，若我们假定矩阵 A=[10,20], B=[20,30], C=[30,40]，那么在以下两种运算顺序中，标量相乘的次数是天差地别：</p><p>(AB)C = 10<em>20</em>30 + 10<em>30</em>40 = 18000</p><p>A(BC) = 20<em>30</em>40 + 10<em>20</em>40 = 32000</p><p>我们可以使用递归关系来找到我们需要的最优解法，首先，我们要用一个函数MCM来得到最小标量相乘次数，那么MCM也可用来定义在所有情况下的最优子段，则：</p><p>再使用动态规划和备忘录法即可得到结果，时间复杂度为O(n³)。</p><pre><code class="python">def mult(chain):    n = len(chain)    # single matrix chain has zero cost    aux = &#123;(i, i): (0,) + chain[i] for i in range(n)&#125;    # i: length of subchain    for i in range(1, n):        # j: starting index of subchain        for j in range(0, n - i):            best = float(&#39;inf&#39;)            # k: splitting point of subchain            for k in range(j, j + i):                # multiply subchains at splitting point                lcost, lname, lrow, lcol = aux[j, k]                rcost, rname, rrow, rcol = aux[k + 1, j + i]                cost = lcost + rcost + lrow * lcol * rcol                var = &#39;(%s%s)&#39; % (lname, rname)                # pick the best one                if cost &lt; best:                    best = cost                    aux[j, j + i] = cost, var, lrow, rcol    return dict(zip([&#39;cost&#39;, &#39;order&#39;, &#39;rows&#39;, &#39;cols&#39;], aux[0, n - 1]))</code></pre><pre><code class="py">## 测试代码mult([(&#39;A&#39;, 10, 20), (&#39;B&#39;, 20, 30), (&#39;C&#39;, 30, 40)])</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> python算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 矩阵链乘法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一、汉诺塔的递归</title>
      <link href="2019/12/03/suan-fa/python-suan-fa/yi-han-nuo-ta-de-di-gui/"/>
      <url>2019/12/03/suan-fa/python-suan-fa/yi-han-nuo-ta-de-di-gui/</url>
      
        <content type="html"><![CDATA[<blockquote class="blockquote-center">汉诺塔问题一直都是经典的递归问题。</blockquote><a id="more"></a><p>大概的思想就是将最大的圆盘移动到右边的柱子上，所以我们需要将其他的圆盘移动到中间的柱子上；</p><p>所以这个问题就变成了如何将 N-1 个圆盘移动到中间的柱子上。</p><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><ul><li>要将 N 个圆盘从左边柱子移动到右边柱子：</li></ul><ol><li>将 N-1 个圆盘从左边柱子移动到中间柱子。</li><li>将最大的圆盘从左边柱子移动到右边柱子。</li><li>将 N-1 个圆盘从中间柱子移动到右边柱子。</li></ol><h4 id="递归的定义："><a href="#递归的定义：" class="headerlink" title="递归的定义："></a>递归的定义：</h4><ul><li>链条：递归的链条比如n*(n-1)就是链条，简单的说就是循环的部分。</li><li>基例：存在一个或多个不需要递归的基例。</li></ul><p>这里left =&gt; right为基例</p><pre><code class="py">def hanoi(height, left=&#39;left&#39;, right=&#39;right&#39;, middle=&#39;middle&#39;):    if height:  # 如果        hanoi(height - 1, left, middle, right)        print(left, &#39;=&gt;&#39;, right)        hanoi(height - 1, middle, right, left)hanoi(3)</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> python算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git的一些常用命令</title>
      <link href="2019/12/02/chang-yong-ming-ling/git-de-yi-xie-chang-yong-ming-ling/"/>
      <url>2019/12/02/chang-yong-ming-ling/git-de-yi-xie-chang-yong-ming-ling/</url>
      
        <content type="html"><![CDATA[<blockquote class="blockquote-center">git的一些常用命令和协作流程</blockquote><a id="more"></a><h3 id="1-远程仓库相关命令"><a href="#1-远程仓库相关命令" class="headerlink" title="1. 远程仓库相关命令"></a>1. 远程仓库相关命令</h3><table><thead><tr><th align="left">命令</th><th align="center">作用</th></tr></thead><tbody><tr><td align="left">$ git clone</td><td align="center">克隆仓库</td></tr><tr><td align="left">$ git remote -v</td><td align="center">查看远程仓库</td></tr><tr><td align="left">$ git remote add [name] [url]</td><td align="center">添加远程仓库</td></tr><tr><td align="left">$ git remote rm [name]</td><td align="center">删除远程仓库</td></tr><tr><td align="left">$ git remote set-url –push[name][newUrl]</td><td align="center">修改远程仓库</td></tr><tr><td align="left">$ git pull [remoteName] [localBranchName]</td><td align="center">拉取远程仓库</td></tr><tr><td align="left">$ git push [remoteName] [localBranchName]</td><td align="center">推送到远端仓库</td></tr></tbody></table><h3 id="2-本地的一些命令"><a href="#2-本地的一些命令" class="headerlink" title="2. 本地的一些命令"></a>2. 本地的一些命令</h3><table><thead><tr><th align="left">命令</th><th align="center">作用</th></tr></thead><tbody><tr><td align="left">$ git clone</td><td align="center">克隆仓库</td></tr><tr><td align="left">$ git add .</td><td align="center">添加文件到stage</td></tr><tr><td align="left">$ git commit -m ‘comments here’</td><td align="center">把stage中的修改提交到本地仓库</td></tr><tr><td align="left">$ git merge master</td><td align="center">master分支合并到当前分支</td></tr><tr><td align="left">$ git merge tool</td><td align="center">调用merge工具</td></tr><tr><td align="left">$ git stash</td><td align="center">把未完成的修改缓存到栈容器中</td></tr><tr><td align="left">$ git stash list</td><td align="center">查看所有缓存</td></tr><tr><td align="left">$ git stash pop</td><td align="center">恢复本地分支到缓存状态</td></tr><tr><td align="left">$ git blame someFile</td><td align="center">查看某个文件的每一行的修改记录（谁在什么时候修改的）</td></tr><tr><td align="left">$ git log</td><td align="center">查看当前分支上面的日志信息</td></tr><tr><td align="left">$ git diff</td><td align="center">查看当前没有add的内容</td></tr><tr><td align="left">$ git diff –cache</td><td align="center">查看已经add但是没有commit的内容</td></tr><tr><td align="left">$ git diff HEAD</td><td align="center">上面两个内容的合并</td></tr><tr><td align="left">$ git reset –hard HEAD</td><td align="center">撤销本地修改</td></tr><tr><td align="left">$ echo $HOME</td><td align="center">查看git config的HOME路径</td></tr><tr><td align="left">$ export $HOME=/c/gitconfig</td><td align="center">配置git config的HOME路径</td></tr></tbody></table><h3 id="3-分支-branch-操作相关命令"><a href="#3-分支-branch-操作相关命令" class="headerlink" title="3. 分支(branch)操作相关命令"></a>3. 分支(branch)操作相关命令</h3><table><thead><tr><th align="left">命令</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left">$ git branch</td><td align="left">查看本地分支</td></tr><tr><td align="left">$ git branch -r</td><td align="left">查看远端分支</td></tr><tr><td align="left">$ git branch [name]</td><td align="left">创建本地分支</td></tr><tr><td align="left">$ git branch -d [name]</td><td align="left">删除分支</td></tr><tr><td align="left">$ git chechout [name]</td><td align="left">切换到这个分支</td></tr><tr><td align="left">$ git chechout -b [name]</td><td align="left">创建并切换到新的分支</td></tr><tr><td align="left">$ git push origin [name]</td><td align="left">创建远程分支(本地分支push到远程)</td></tr><tr><td align="left">$ git push origin test:master</td><td align="left">提交本地test分支作为远程的master分支</td></tr><tr><td align="left">$ git push origin test:test</td><td align="left">提交本地test分支作为远程的test分支</td></tr><tr><td align="left">$ git push origin :test</td><td align="left">刚提交到远程的test将被删除，但是本地还会保存的，不用担心</td></tr></tbody></table><h3 id="4-版本-tag-操作相关命令"><a href="#4-版本-tag-操作相关命令" class="headerlink" title="4. 版本(tag)操作相关命令"></a>4. 版本(tag)操作相关命令</h3><table><thead><tr><th align="left">命令</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left">git tag</td><td align="left">查看版本</td></tr><tr><td align="left">git tag [name]</td><td align="left">创建版本</td></tr><tr><td align="left">git tag -d [name]</td><td align="left">删除版本</td></tr><tr><td align="left">git tag -r</td><td align="left">查看远端版本</td></tr><tr><td align="left">git push origin [name]</td><td align="left">创建远程版本(本地版本push到远程)</td></tr><tr><td align="left">git push origin :refs/tags/[name]</td><td align="left">删除远程版本</td></tr></tbody></table><h3 id="团队协作的一般流程"><a href="#团队协作的一般流程" class="headerlink" title="团队协作的一般流程"></a>团队协作的一般流程</h3><h4 id="克隆一个全新的项目，完成新功能并且提交："><a href="#克隆一个全新的项目，完成新功能并且提交：" class="headerlink" title="克隆一个全新的项目，完成新功能并且提交："></a>克隆一个全新的项目，完成新功能并且提交：</h4><ol><li>git clone XXX   //克隆代码库</li><li>git checkout -b test   //新建分支</li><li>modify some files   //完成修改</li><li>git add .   //把修改加入stage中</li><li>git commit -m ‘’  //提交修改到test分支</li><li>review代码</li><li>git checkout master   //切换到master分支</li><li>git pull   //更新代码</li><li>git checkout test     //切换到test分支</li><li>git meger master   //把master分支的代码merge到test分支</li><li>git push origin 分支名  //把test分支的代码push到远程库</li></ol><h4 id="目前正在test分支上面开发某个功能，但是没有完成。突然一个紧急的bug需要处理"><a href="#目前正在test分支上面开发某个功能，但是没有完成。突然一个紧急的bug需要处理" class="headerlink" title="目前正在test分支上面开发某个功能，但是没有完成。突然一个紧急的bug需要处理"></a>目前正在test分支上面开发某个功能，但是没有完成。突然一个紧急的bug需要处理</h4><ol><li>git add .</li><li>git stash</li><li>git checkout bugFixBranch</li><li>git pull –rebase origin master</li><li>fix the bug</li><li>it add .</li><li>git commit -m ‘’</li><li>git push</li><li>git checkout test</li><li>g2. it stash pop</li><li>continue new feature’s developmen</li></ol>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git 备忘 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo 常用命令 备忘</title>
      <link href="2019/11/29/chang-yong-ming-ling/hexo-chang-yong-ming-ling-bei-wang/"/>
      <url>2019/11/29/chang-yong-ming-ling/hexo-chang-yong-ming-ling-bei-wang/</url>
      
        <content type="html"><![CDATA[<blockquote class="blockquote-center">如果忘了hexo的命令怎么办呢？？？</blockquote><a id="more"></a><h3 id="init"><a href="#init" class="headerlink" title="init"></a>init</h3><blockquote><p>$ hexo init [folder]</p></blockquote><p>新建一个网站。如果没有设置 folder ，Hexo 默认在目前的文件夹建立网站。</p><h3 id="new"><a href="#new" class="headerlink" title="new"></a>new</h3><blockquote><p>$ hexo new [layout] <title></p></blockquote><p>新建时 layout  Post layout. Use post, page, draft or whatever you want.<br>post 表示发布，page 单独一个页面 ，draft草稿</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>-p, –path</td><td>自定义新文章的路径</td></tr><tr><td>-r, –replace</td><td>如果存在同名文章，将其替换</td></tr><tr><td>-s, –slug</td><td>文章的 Slug，作为新文章的文件名和发布后的 URL</td></tr></tbody></table><p>比如在用 -p 时<code>hexo new page --path about/me &quot;About me&quot;</code></p><p>以上命令会创建一个 source/about/me.md 文件，同时 Front Matter 中的 title 为 “About me”</p><h3 id="generate"><a href="#generate" class="headerlink" title="generate"></a>generate</h3><p>可以简写为 hexo g</p><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td>-d, –deploy</td><td>文件生成后立即部署网站</td></tr><tr><td>-w, –watch</td><td>监视文件变动</td></tr><tr><td>-b, –bail</td><td>生成过程中如果发生任何未处理的异常则抛出异常</td></tr><tr><td>-f, –force</td><td>强制重新生成文件</td></tr><tr><td>-c, –concurrency</td><td>最大同时生成文件的数量，默认无限制</td></tr></tbody></table><h3 id="publish"><a href="#publish" class="headerlink" title="publish"></a>publish</h3><p>用于发布草稿</p><blockquote><p>$ hexo publish [layout] <filename></p></blockquote><h3 id="server"><a href="#server" class="headerlink" title="server"></a>server</h3><blockquote><p>$ hexo server</p></blockquote><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td>-p, –port</td><td>重设端口</td></tr><tr><td>-s, –static</td><td>只使用静态文件</td></tr><tr><td>-l, –log</td><td>启动日记记录，使用覆盖记录格式</td></tr></tbody></table><h3 id="deploy"><a href="#deploy" class="headerlink" title="deploy"></a>deploy</h3><p>部署站点</p><blockquote><p>$ hexo deploy</p></blockquote><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>-g, –generate</td><td>部署之前预先生成静态文件</td></tr></tbody></table><p>该命令可以简写为</p><blockquote><p>hexo d</p></blockquote><h3 id="clean"><a href="#clean" class="headerlink" title="clean"></a>clean</h3><blockquote><p>hexo clean<br>清除缓存文件 (db.json) 和已生成的静态文件 (public)。<br>在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。</p></blockquote><h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><p>列出网站资料</p><blockquote><p>hexo list</p></blockquote><p>hexo version</p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 备忘 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客-添加评论系统</title>
      <link href="2019/11/29/bo-ke/next-tian-jia-ping-lun-xi-tong/"/>
      <url>2019/11/29/bo-ke/next-tian-jia-ping-lun-xi-tong/</url>
      
        <content type="html"><![CDATA[<blockquote class="blockquote-center">我查看了很多的评论都说这个valine评论系统比较好，查了官网，也确实，所以，，，就你了</blockquote><div style = "text-align:center"></div> <a id="more"></a><hr><h2 id="valine介绍"><a href="#valine介绍" class="headerlink" title="valine介绍"></a>valine介绍</h2><p>根据valine 介绍特性中描述，valine稳定高效，支持表情，无后端，而且支持markdown！！</p><p>那么就开始愉快的记录下这个安装适配的过程吧！</p><h3 id="注册LeanClond"><a href="#注册LeanClond" class="headerlink" title="注册LeanClond"></a>注册LeanClond</h3><p>已经注册过的跳过<br><a href="https://www.leancloud.cn/">LeanClond官网链接</a><br>注意现在注册是需要验证身份的</p><p>注册登录后进入<code>控制台</code>点解<code>创建应用</code><br><img src="https://s2.ax1x.com/2019/11/29/QAgJ54.png" alt="QAgJ54.png"></p><p>创建好后点击进入应用，选择左下角的<code>设置</code>&gt;<code>应用Key</code>，然后就能看到你的APP ID和APP Key了：</p><p><img src="https://s2.ax1x.com/2019/11/29/QA2x1A.png" alt="QA2x1A.png"></p><p>拿到了<code>AppID</code> 和<code>AppKey</code>就可以开始设置你的next的主题了,打开<code>_config.yml</code>文件,<code>ctrl + f</code>搜索<code>valine</code><br><img src="https://s2.ax1x.com/2019/11/29/QAWCvR.png" alt="QAWCvR.png"></p><p>把<code>enable</code>的值改成<code>true</code>,在<code>appid</code>和<code>appkey</code>填入你在leancloud中得到的<code>appid</code>和<code>appkey</code>的值，然后保存退出就可以了。</p><p>在终端输入</p><blockquote><p>hexo clean</p></blockquote><p>然后输入</p><blockquote><p>hexo s</p></blockquote><p>就可以看到文章下面的评论框了</p><h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><p>我用的next主题是v7 如果你版本是v5或以下的可能有莫名奇妙的问题请到相应的主题文件夹下命令</p><blockquote><p>git pull</p></blockquote><p>升级next主题</p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> next </tag>
            
            <tag> 博客评论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>renger使用</title>
      <link href="2019/10/12/linux/renger-shi-yong/"/>
      <url>2019/10/12/linux/renger-shi-yong/</url>
      
        <content type="html"><![CDATA[<blockquote class="blockquote-center">无意间看见了renger终端文件管理的工具，高兴惨了，以后再也不用cd过来cd过去了</blockquote><div style = "text-align:center"></div> <a id="more"></a><h1 id="ranger的使用"><a href="#ranger的使用" class="headerlink" title="ranger的使用"></a>ranger的使用</h1><hr><p>下面介绍下ranger终端文件管理的使用，都是网上爬的算是收藏吧！</p><h2 id="一、安装"><a href="#一、安装" class="headerlink" title="一、安装"></a>一、安装</h2><pre><code>sudo apt install ranger</code></pre><h2 id="二、配置"><a href="#二、配置" class="headerlink" title="二、配置"></a>二、配置</h2><ol><li>配置文件<br>首先复制配置文件到主目录:<pre><code>ranger --copy-config=all</code></pre></li></ol><p>然后自己到~/.config/ranger中配置各种选项即可<br>2. 配置ranger<br>在～/.config/ranger中有ranger的配置文件.<br>找到文件<code>scope.sh</code>中, 在externsions部分注释掉不想预览的文件类型, 在那行上面添加”#”注释掉即可. ranger在预览rar等压缩包时会运行得比较慢.<br><code>rc.conf</code>保存着快捷键的说明<br>3. 自动挂载U盘等外部存储位置,需要安装usbmount:</p><pre><code>sudo apt-get install usbmountsudo vim /etc/usbmount/usbmount.conf</code></pre><p>在<code>MOUNTOPTIONS</code>那行添加<code>user</code>即可使普通用户也对挂载的U盘拥有写权限, 如下:<br><code>MOUNTOPTIOS=&quot;rw,user,noatime,nodiratime&quot; </code></p><h2 id="三、-快捷键"><a href="#三、-快捷键" class="headerlink" title="三、 快捷键"></a>三、 快捷键</h2><p>下面列出常用操作的快捷键</p><p>?  查看帮助</p><h3 id="浏览"><a href="#浏览" class="headerlink" title="浏览:"></a>浏览:</h3><p>H   后退<br>L   前进<br>gg  跳到顶端<br>G   跳到底端<br>gh  go home<br>gn  新建标签<br>f   查找<br>/   搜素<br>g   快速进入目录</p><h3 id="编辑"><a href="#编辑" class="headerlink" title="编辑:"></a>编辑:</h3><p>space   选择<br>uv      取消选择</p><p>yy      复制<br>dd      剪切<br>pp      粘贴<br>delete  删除<br>cw      重命名<br>A       在当前名称基础上重命名<br>I       类似A, 但是光标会跳到起始位置<br>Ctrl-f  向下翻页<br>Ctrl-b  向上翻页</p><h3 id="书签"><a href="#书签" class="headerlink" title="书签:"></a>书签:</h3><p>m       新建书签<br>`       打开书签<br>um      删除书签</p><h3 id="标签"><a href="#标签" class="headerlink" title="标签:"></a>标签:</h3><p>gn / C-n        新建标签<br>TAB / S-TAB     切换标签<br>A-Right, A-Left 切换标签<br>gc / C-w        关闭标签</p><h3 id="排序"><a href="#排序" class="headerlink" title="排序:"></a>排序:</h3><p>on/ob   根据文件名进行排序(natural/basename)<br>oc      根据改变时间进行排序 (Change Time 文件的权限组别和文件自身数据被修改的时间)<br>os      根据文件大小进行排序(Size)<br>ot      根据后缀名进行排序 (Type)</p><p>oa      根据访问时间进行排序 (Access Time 访问文件自身数据的时间)<br>om      根据修改进行排序 (Modify time 文件自身内容被修改的时间)</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他:"></a>其他:</h3><p>zh      显示隐藏文件</p><p>zp      打开/关闭文件预览功能<br>zP      打开目录预览功能</p><h3 id="链接-Link"><a href="#链接-Link" class="headerlink" title="链接(Link):"></a>链接(Link):</h3><p>pl      粘贴绝对路径的链接<br>pL      粘贴相对路径的链接<br>phl     硬链接</p><h3 id="批量改名"><a href="#批量改名" class="headerlink" title="批量改名:"></a>批量改名:</h3><p>批量选择文件后, 键入命令:bulkname, 会打开编辑器, 其中的文件名编辑后保存退出, 再次打开操作确认编辑, 然后就批量改名了, 如果想取消批量改名, 在确认时把文件内容删除即可.</p><h3 id="任务管理"><a href="#任务管理" class="headerlink" title="任务管理:"></a>任务管理:</h3><p>在执行某些操作(比如复制一个大文件)时不能立即完成, 这在 ranger 中就是一个任务. 你可以停止, 启动某个任务, 也可以对某个任务设置优先级.</p><p>w: 打开/关闭任务视图. 在w打开的任务视图中:<br>    dd: 终止一个任务<br>    J: 降低当前任务的优先级<br>    K: 提升当前任务的优先级</p><h3 id="其他-1"><a href="#其他-1" class="headerlink" title="其他:"></a>其他:</h3><dl><dt>zf      过滤器(如过滤pdf文件, zf+pdf,回车)<br>S       在当前目录打开终端<br>z(*)    改变设置, <em>表示在弹出选项中的选择<br>o(</em>)    改变排序方式<br>! / s   使用shell命令(！shell -w ls -hl %s,%s代表当前被选中的文件)</dt><dd>使用ranger命令(3? 查看可用命令)<br>:set colorscheme snow 设置颜色模式</dd></dl><h2 id="四、快速预览"><a href="#四、快速预览" class="headerlink" title="四、快速预览"></a>四、快速预览</h2><p>安装一下程序可以实现快速预览:</p><p>elinks, html<br>highlight,text/code<br>img2txt,image<br>atool,压缩包<br>pdf2text,pdf<br>medinfo,audio/video</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ranger </tag>
            
            <tag> 文件浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>后端跨域的问题</title>
      <link href="2019/07/24/qian-duan/hou-duan-kua-yu-de-wen-ti/"/>
      <url>2019/07/24/qian-duan/hou-duan-kua-yu-de-wen-ti/</url>
      
        <content type="html"><![CDATA[<blockquote class="blockquote-center">在前端调用api的时候无法获得Flask本地服务器后端返回的json数据,在浏览器控制台爆出了</blockquote><a id="more"></a><blockquote><p>No ‘Access-Control-Allow-Origin’ header is present on the requested resource. Origin ‘null’ is therefore not allowed access.<br><img src="https://s2.ax1x.com/2019/07/24/eVjrpd.jpg" alt="eVjrpd.jpg"></p></blockquote><p>大致意思好像是访问没被允许</p><h3 id="事情原因"><a href="#事情原因" class="headerlink" title="事情原因"></a>事情原因</h3><p>我参照<a href="https://www.taniarascia.com/how-to-connect-to-an-api-with-javascript/">https://www.taniarascia.com/how-to-connect-to-an-api-with-javascript/</a><br>去学习api的知识<br>在修改了js请求后端发过来的json数据后无法访问，爆出了刚才的错误<br><img src="https://s2.ax1x.com/2019/07/24/eVjBfH.jpg" alt="eVjBfH.jpg"></p><p>先开始不知道是怎么回事，前端一直无法获得json数据，但是请求时对的，<br>找了好久，差点误入歧途，全都是关于前端怎么跨域访问的教程，完全是借助相关的漏洞获取没有被允许的数据资源，</p><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>后端跨域访问数据是需要后端允许的，官方是通过CORS放权解决<br>它会在你发送下面几种HTTP请求时触发：</p><ul><li>不同的域名 （比如在网站 example.com 请求 api.com)</li><li>不同的子域名 （比如在网站 example.com 请求 api.example.com)</li><li>不同的端口 （比如在网站 example.com 请求 example.com:3001)</li><li>不同协议 （比如在网站 <a href="https://example.com/">https://example.com</a> 请求 <a href="http://example.com/">http://example.com</a>)<br>这个机制阻止攻击者在一些网站上放置js脚本</li></ul><ol><li><p>安装 flask-cors</p><blockquote><p>pip install flask-cors</p></blockquote></li><li><p>导入包</p><blockquote><p>from flask_cors import CORS</p></blockquote></li><li><p>全局数据app应用的数据</p><blockquote><p>app = Flask(<strong>name</strong>)<br>CORS(app)</p></blockquote></li></ol><h3 id="再次请求"><a href="#再次请求" class="headerlink" title="再次请求"></a>再次请求</h3><p>运行index.html文件</p><p><img src="https://s2.ax1x.com/2019/07/24/eVviB6.jpg" alt="eVviB6.jpg"></p><p>OK了</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> api </tag>
            
            <tag> 跨域 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Centos服务器配置python3解释器</title>
      <link href="2019/07/11/fu-wu-qi/centos-fu-wu-qi-pei-zhi-python3-jie-shi-qi/"/>
      <url>2019/07/11/fu-wu-qi/centos-fu-wu-qi-pei-zhi-python3-jie-shi-qi/</url>
      
        <content type="html"><![CDATA[<blockquote class="blockquote-center">解决Centos 没有python3解释器的问题</blockquote><a id="more"></a><h2 id="腾讯云上面注册一个账号"><a href="#腾讯云上面注册一个账号" class="headerlink" title="腾讯云上面注册一个账号"></a>腾讯云上面注册一个账号</h2><p>我当时用的centos 7.6<br>反正安装的时候各种问题</p><h3 id="连接ssh"><a href="#连接ssh" class="headerlink" title="连接ssh:"></a>连接ssh:</h3><p>ssh root@公网ip  然后输入密码</p><p>改端口,post 改成56或者其他，，，为了安全</p><blockquote><p>vim /etc/ssh/sshd_config</p></blockquote><p>然后从新启用端口</p><blockquote><p>systemctl restart sshd </p></blockquote><h3 id="安装python3"><a href="#安装python3" class="headerlink" title="安装python3"></a>安装python3</h3><p>先下载python3的linux包，或者直接上传<br>找一个目录解压</p><blockquote><p>tar xf Python-xxx</p></blockquote><p>安装必要的东西，因为安装的时候报错sqlite有问题，没有编译，都一起安装了。</p><blockquote><p>yum install -y zlib zlib-devel sqlite-devel</p></blockquote><p>指定目录安装python3 ，顺便安装pip, &amp;&amp; 为成功则继续执行</p><blockquote><p>./configure –prefix=/usr/local/python-3.6.4 –with-ensurepip &amp;&amp; make &amp;&amp; make install</p></blockquote><p>添加快捷方式，相当于环境变量</p><blockquote><p>ln -s /usr/local/python-3.6.4/bin/python3 /usr/local/bin<br>ln -s /usr/local/python-3.6.4/bin/pip3 /usr/local/bin</p></blockquote><p>这个时候python3，pip3就可以用了，</p><h3 id="安装必要包，解决可能出现的问题"><a href="#安装必要包，解决可能出现的问题" class="headerlink" title="安装必要包，解决可能出现的问题"></a>安装必要包，解决可能出现的问题</h3><blockquote><p>yum install -y postgresql<br>yum install -y gcc<br>yum install -y postgresql-debel</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分享 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用Github+Hexo搭建属于自己的个人博客</title>
      <link href="2019/07/01/bo-ke/yong-github-hexo-da-jian-shu-yu-zi-ji-de-ge-ren-bo-ke/"/>
      <url>2019/07/01/bo-ke/yong-github-hexo-da-jian-shu-yu-zi-ji-de-ge-ren-bo-ke/</url>
      
        <content type="html"><![CDATA[<blockquote class="blockquote-center">搭建博客系统后也不知道写些什么，正好刚刚用Github+Hexo搭建了一个博客系统，就先记录下吧！</blockquote><a id="more"></a><h2 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h2><p>git下载<a href="https://git-scm.com/download/win">连接</a><br>安装完成后<br><img src="https://s2.ax1x.com/2019/07/01/ZGFCtA.jpg" alt="安装完成后"><br>关于git的使用可参照这个网站<a href="https://www.liaoxuefeng.com/wiki/896043488029600/896067074338496">廖雪峰</a></p><h2 id="绑定github"><a href="#绑定github" class="headerlink" title="绑定github"></a>绑定github</h2><p>打开Git Bash 输入</p><blockquote><p>git config –global user.name “你的GitHub用户名”<br>git config –global user.email “你的GitHub注册邮箱”</p></blockquote><p>生成ssh密钥文件：</p><blockquote><p>ssh-keygen -t rsa -C “你的GitHub注册邮箱”</p></blockquote><p>在目录C:\Users\Administrator.ssh找到id_rsa.pub文件打开<a href="">公钥目录</a><br>然后打开<a href="https://github.com/settings/keys">https://github.com/settings/keys</a>页面，新建new ssh key,把刚刚生生的你看不懂的长串字段粘贴进去，标题随便取,然后点Add SSH key<br><img src="https://s2.ax1x.com/2019/07/01/ZGk15d.jpg" alt="添加ssh key"><br>显示添加后基本就可以了</p><h2 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h2><p><a href="https://npm.taobao.org/mirrors/node/v10.16.0/node-v10.16.0-x64.msi">下载连接</a><br>安装后在cmd窗口输入</p><blockquote><p>node -v</p></blockquote><p>出现版本就表示安装上了<br><a href="https://imgchr.com/i/ZGkvIH"><img src="https://s2.ax1x.com/2019/07/01/ZGkvIH.jpg" alt="ZGkvIH.jpg"></a></p><h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><p>直接可以在cmd窗口输入<br>因为国外的镜像源很慢，所以更换国内的镜像源<br>输入:</p><blockquote><p>npm install -g cnpm –registry=<a href="https://registry.npm.taobao.org/">https://registry.npm.taobao.org</a></p></blockquote><p>跟换完成后用cnpm 包管理器<br>然后输入命令安装hexo：</p><blockquote><p>cnpm install -g hexo-cli</p></blockquote><p>验证hexo是否安装完成：</p><blockquote><p>hexo -v</p></blockquote><p><a href="https://imgchr.com/i/ZGEuAe"><img src="https://s2.ax1x.com/2019/07/01/ZGEuAe.jpg" alt="ZGEuAe.jpg"></a></p><p>表示安装完成了，是不是很简单</p><p>新建一个文件夹作为你blog的安装目录，不建议桌面<br>在新建好的文件夹中右击打开 git bash here输入：</p><blockquote><p>hexo init</p></blockquote><p>此后会自动生成必要文件完成后验证运行输入：</p><blockquote><p>hexo g</p></blockquote><p>生成静态文件</p><blockquote><p>hexo s</p></blockquote><p><a href="https://imgchr.com/i/ZGE09s"><img src="https://s2.ax1x.com/2019/07/01/ZGE09s.jpg" alt="ZGE09s.jpg"></a></p><p>运行后在浏览器中打开localhost:4000/就可以看见创建的博客了，具体使用参照hexo官方<a href="https://hexo.io/zh-cn/docs/commands">使用文档</a></p><h2 id="部署到github"><a href="#部署到github" class="headerlink" title="部署到github"></a>部署到github</h2><p>在github上面新建一个仓库<br><a href="https://imgchr.com/i/ZGEhC9"><img src="https://s2.ax1x.com/2019/07/01/ZGEhC9.jpg" alt="ZGEhC9.jpg"></a><br>仓库名一定是  “你用户名”.github.io</p><p>复制生成的SSH连接，<br>在init 后的目录下找到_config.yml用文本打开添加</p><blockquote><p>deploy:<br>  type: git<br>  repository: “你复制的SSH连接”<br>  branch: master</p></blockquote><p>然后保存</p><p>然后安装一个部署插件</p><blockquote><p>cnpm install –save hexo-deployer-git</p></blockquote><p>安装后<br>输入:</p><blockquote><p>hexo d</p></blockquote><p>就可以部署到远端了，<br>用浏览器打开 “你用户名”.github.io就可以看到你部署后的博客系统了</p><hr><p>换了电脑，移动本地的blog文件后<code>hexo d</code>出现<code>LF will be replaced by CRLF</code>的警告<br>查阅了一番后似乎没有必要<br>直接禁用转化就可以了</p><pre><code> git config --global core.autocrlf false</code></pre><p>此后用hexo d就不会出现这样的问题了,可以正常部署</p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
